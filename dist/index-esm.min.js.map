{"version":3,"file":"index-esm.min.js","sources":["../lib/BoundingBox2D.js","../lib/Polygon2D.js","../lib/Circle2D.js","../node_modules/kld-polynomial/lib/Polynomial.js","../node_modules/kld-polynomial/lib/SqrtPolynomial.js","../node_modules/kld-affine/lib/Point2D.js","../node_modules/kld-affine/lib/Vector2D.js","../node_modules/kld-affine/lib/Matrix2D.js","../lib/CubicBezier2D.js","../lib/Ellipse2D.js","../lib/Line2D.js","../lib/QuadraticBezier2D.js","../lib/Rectangle2D.js"],"sourcesContent":["/**\n *  BoundingBox2D.js\n *\n *  @module BoundingBox2D\n *  @copyright 2011-2019 Kevin Lindsey\n */\n\n/**\n *  BoundingBox2D\n */\nclass BoundingBox2D {\n    /**\n     *  @param {number} x\n     *  @param {number} y\n     *  @param {number} width\n     *  @param {number} height\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     *  overlaps\n     *\n     *  @param {module:kld-contours~BoundingBox2D} that\n     *  @returns {boolean}\n     */\n    overlaps(that) {\n        return (\n            this.x < (that.x + that.width) && (this.x + this.width) > that.x &&\n            this.y < (that.y + that.height) && (this.y + this.height) > that.y\n        );\n    }\n\n    /**\n     *  isEmpty\n     *\n     *  @returns {boolean}\n     */\n    isEmpty() {\n        return this.width !== 0 && this.height !== 0;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return (\n            \"bbox(\" +\n            this.x + \",\" +\n            this.y + \",\" +\n            this.width + \",\" +\n            this.height + \")\"\n        );\n    }\n}\n\nexport default BoundingBox2D;\n","/**\n *  Polygon2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Polygon2D\n */\nimport BoundingBox2D from \"./BoundingBox2D.js\";\n\n/**\n *  Polygon2D\n */\nclass Polygon2D {\n    /**\n     *  @param {Array<module:kld-affine.Point2D>} points\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    constructor(points) {\n        this.points = (points !== undefined) ? points : [];\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        if (this.points.length > 0) {\n            let min = this.points[0];\n            let max = this.points[0];\n\n            for (let i = 1; i < this.points.length; i++) {\n                const point = this.points[i];\n\n                min = min.min(point);\n                max = max.max(point);\n            }\n\n            return new BoundingBox2D(\n                min.x,\n                min.y,\n                max.x - min.x,\n                max.y - max.y\n            );\n        }\n\n        return new BoundingBox2D(0, 0, 0, 0);\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return this;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return this.points.map(p => {\n            return `${p.x}, ${p.y}`;\n        }).join(\" \");\n    }\n}\n\nexport default Polygon2D;\n","/* eslint-disable class-methods-use-this */\n/**\n *  Circle2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Circle2D\n */\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  Circle2D\n */\nclass Circle2D {\n    /**\n     *  @param {module:kld-affine.Point2D} center\n     *  @param {number} radius\n     *  @returns {module:kld-contours~Circle2D}\n     */\n    constructor(center, radius) {\n        this.center = center;\n        this.radius = radius;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        return new BoundingBox2D(\n            this.center.x - this.radius,\n            this.center.y - this.radius,\n            this.radius * 2.0,\n            this.radius * 2.0\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return new Polygon2D();\n    }\n}\n\nexport default Circle2D;\n","/* eslint-disable camelcase, unicorn/prefer-type-error */\n/**\n *  Polynomial.js\n *\n *  @module Polynomial\n *  @copyright 2002-2019 Kevin Lindsey<br>\n *  -<br>\n *  Contribution {@link http://github.com/Quazistax/kld-polynomial}<br>\n *  2015 Robert Benko (Quazistax) <quazistax@gmail.com><br>\n *  MIT license\n */\n\n/**\n *  Sign of a number (+1, -1, +0, -0).\n *\n *  @param {number} x\n *  @returns {number}\n */\nfunction sign(x) {\n    // eslint-disable-next-line no-self-compare\n    return typeof x === \"number\" ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;\n}\n\n\n/**\n *  Polynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass Polynomial {\n    /**\n     *  Polynomial\n     *\n     *  @param {Array<number>} coefs\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    constructor(...coefs) {\n        this.coefs = [];\n\n        for (let i = coefs.length - 1; i >= 0; i--) {\n            this.coefs.push(coefs[i]);\n        }\n\n        this._variable = \"t\";\n        this._s = 0;\n    }\n\n    /**\n     *  interpolate\n     *\n     *  Based on poloint in \"Numerical Recipes in C, 2nd Edition\", pages 109-110\n     *\n     *  @param {Array<number>} xs\n     *  @param {Array<number>} ys\n     *  @param {number} n\n     *  @param {number} offset\n     *  @param {number} x\n     *\n     *  @returns {{y: number, dy: number}}\n     */\n    static interpolate(xs, ys, n, offset, x) {\n        if (xs.constructor !== Array || ys.constructor !== Array) {\n            throw new Error(\"Polynomial.interpolate: xs and ys must be arrays\");\n        }\n        if (isNaN(n) || isNaN(offset) || isNaN(x)) {\n            throw new Error(\"Polynomial.interpolate: n, offset, and x must be numbers\");\n        }\n\n        let i;\n        let y = 0;\n        let dy = 0;\n        const c = new Array(n);\n        const d = new Array(n);\n        let ns = 0;\n\n        let diff = Math.abs(x - xs[offset]);\n\n        for (i = 0; i < n; i++) {\n            const dift = Math.abs(x - xs[offset + i]);\n\n            if (dift < diff) {\n                ns = i;\n                diff = dift;\n            }\n            c[i] = d[i] = ys[offset + i];\n        }\n\n        y = ys[offset + ns];\n        ns--;\n\n        for (let m = 1; m < n; m++) {\n            for (i = 0; i < n - m; i++) {\n                const ho = xs[offset + i] - x;\n                const hp = xs[offset + i + m] - x;\n                const w = c[i + 1] - d[i];\n                let den = ho - hp;\n\n                if (den === 0.0) {\n                    throw new Error(\"Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)\");\n                }\n\n                den = w / den;\n                d[i] = hp * den;\n                c[i] = ho * den;\n            }\n\n            dy = (2 * (ns + 1) < (n - m)) ? c[ns + 1] : d[ns--];\n            y += dy;\n        }\n\n        return {y, dy};\n    }\n\n    /**\n     *  Newton's (Newton-Raphson) method for finding Real roots on univariate function. <br/>\n     *  When using bounds, algorithm falls back to secant if newton goes out of range.\n     *  Bisection is fallback for secant when determined secant is not efficient enough.\n     *  @see {@link http://en.wikipedia.org/wiki/Newton%27s_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Secant_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Bisection_method}\n     *\n     *  @param {number} x0 - Inital root guess\n     *  @param {Function} f - Function which root we are trying to find\n     *  @param {Function} df - Derivative of function f\n     *  @param {number} max_iterations - Maximum number of algorithm iterations\n     *  @param {number} [min] - Left bound value\n     *  @param {number} [max] - Right bound value\n     *  @returns {number} root\n     */\n    static newton_secant_bisection(x0, f, df, max_iterations, min, max) {\n        let x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;\n        let y, y_atmin, y_atmax;\n\n        x = x0;\n\n        const ACCURACY = 14;\n        const min_correction_factor = Math.pow(10, -ACCURACY);\n        const isBounded = (typeof min === \"number\" && typeof max === \"number\");\n\n        if (isBounded) {\n            if (min > max) {\n                throw new Error(\"newton root finding: min must be greater than max\");\n            }\n\n            y_atmin = f(min);\n            y_atmax = f(max);\n\n            if (sign(y_atmin) === sign(y_atmax)) {\n                throw new Error(\"newton root finding: y values of bounds must be of opposite sign\");\n            }\n        }\n\n        const isEnoughCorrection = function() {\n            // stop if correction is too small or if correction is in simple loop\n            return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x)) ||\n                (prev_x_ef_correction === (x - x_correction) - x);\n        };\n\n\n        for (let i = 0; i < max_iterations; i++) {\n            dfx = df(x);\n\n            if (dfx === 0) {\n                if (prev_dfx === 0) {\n                    // error\n                    throw new Error(\"newton root finding: df(x) is zero\");\n                }\n                else {\n                    // use previous derivation value\n                    dfx = prev_dfx;\n                }\n                // or move x a little?\n                // dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);\n            }\n\n            prev_dfx = dfx;\n            y = f(x);\n            x_correction = y / dfx;\n            x_new = x - x_correction;\n\n            if (isEnoughCorrection()) {\n                break;\n            }\n\n            if (isBounded) {\n                if (sign(y) === sign(y_atmax)) {\n                    max = x;\n                    y_atmax = y;\n                }\n                else if (sign(y) === sign(y_atmin)) {\n                    min = x;\n                    y_atmin = y;\n                }\n                else {\n                    x = x_new;\n                    break;\n                }\n\n                if ((x_new < min) || (x_new > max)) {\n                    if (sign(y_atmin) === sign(y_atmax)) {\n                        break;\n                    }\n\n                    const RATIO_LIMIT = 50;\n                    const AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)\n                    const dy = y_atmax - y_atmin;\n                    const dx = max - min;\n\n                    if (dy === 0) {\n                        x_correction = x - (min + dx * 0.5);\n                    }\n                    else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {\n                        x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));\n                    }\n                    else {\n                        x_correction = x - (min - y_atmin / dy * dx);\n                    }\n                    x_new = x - x_correction;\n\n                    if (isEnoughCorrection()) {\n                        break;\n                    }\n                }\n            }\n\n            prev_x_ef_correction = x - x_new;\n            x = x_new;\n        }\n\n        return x;\n    }\n\n    /**\n     *  Clones this polynomial and return the clone.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    clone() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice();\n\n        return poly;\n    }\n\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     */\n    eval(x) {\n        if (isNaN(x)) {\n            throw new Error(`Polynomial.eval: parameter must be a number, got '${x}'`);\n        }\n\n        let result = 0;\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            result = result * x + this.coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    add(that) {\n        const result = new Polynomial();\n        const d1 = this.getDegree();\n        const d2 = that.getDegree();\n        const dmax = Math.max(d1, d2);\n\n        for (let i = 0; i <= dmax; i++) {\n            const v1 = (i <= d1) ? this.coefs[i] : 0;\n            const v2 = (i <= d2) ? that.coefs[i] : 0;\n\n            result.coefs[i] = v1 + v2;\n        }\n\n        return result;\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    multiply(that) {\n        const result = new Polynomial();\n\n        for (let i = 0; i <= this.getDegree() + that.getDegree(); i++) {\n            result.coefs.push(0);\n        }\n\n        for (let i = 0; i <= this.getDegree(); i++) {\n            for (let j = 0; j <= that.getDegree(); j++) {\n                result.coefs[i + j] += this.coefs[i] * that.coefs[j];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  divide_scalar\n     *\n     *  @param {number} scalar\n     */\n    divide_scalar(scalar) {\n        for (let i = 0; i < this.coefs.length; i++) {\n            this.coefs[i] /= scalar;\n        }\n    }\n\n    /**\n     *  simplify\n     *\n     *  @param {number} TOLERANCE\n     */\n    simplify(TOLERANCE) {\n        if (TOLERANCE === undefined) {\n            TOLERANCE = 1e-12;\n        }\n\n        for (let i = this.getDegree(); i >= 0; i--) {\n            if (Math.abs(this.coefs[i]) <= TOLERANCE) {\n                this.coefs.pop();\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    /**\n     *  bisection\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *\n     *  @returns {number}\n     */\n    bisection(min, max) {\n        let minValue = this.eval(min);\n        let maxValue = this.eval(max);\n        let result;\n\n        if (Math.abs(minValue) <= Polynomial.TOLERANCE) {\n            result = min;\n        }\n        else if (Math.abs(maxValue) <= Polynomial.TOLERANCE) {\n            result = max;\n        }\n        else if (minValue * maxValue <= 0) {\n            const tmp1 = Math.log(max - min);\n            const tmp2 = Math.LN10 * Polynomial.ACCURACY;\n            const iters = Math.ceil((tmp1 + tmp2) / Math.LN2);\n\n            for (let i = 0; i < iters; i++) {\n                result = 0.5 * (min + max);\n                const value = this.eval(result);\n\n                if (Math.abs(value) <= Polynomial.TOLERANCE) {\n                    break;\n                }\n\n                if (value * minValue < 0) {\n                    max = result;\n                    maxValue = value;\n                }\n                else {\n                    min = result;\n                    minValue = value;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const coefs = [];\n        const signs = [];\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            let value = Math.round(this.coefs[i] * 1000) / 1000;\n\n            if (value !== 0) {\n                const signString = (value < 0) ? \" - \" : \" + \";\n\n                value = Math.abs(value);\n\n                if (i > 0) {\n                    if (value === 1) {\n                        value = this._variable;\n                    }\n                    else {\n                        value += this._variable;\n                    }\n                }\n\n                if (i > 1) {\n                    value += \"^\" + i;\n                }\n\n                signs.push(signString);\n                coefs.push(value);\n            }\n        }\n\n        signs[0] = (signs[0] === \" + \") ? \"\" : \"-\";\n\n        let result = \"\";\n\n        for (let i = 0; i < coefs.length; i++) {\n            result += signs[i] + coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  trapezoid\n     *\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 137\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} n\n     *  @returns {number}\n     */\n    trapezoid(min, max, n) {\n        if (isNaN(min) || isNaN(max) || isNaN(n)) {\n            throw new Error(\"Polynomial.trapezoid: parameters must be numbers\");\n        }\n\n        const range = max - min;\n\n        if (n === 1) {\n            const minValue = this.eval(min);\n            const maxValue = this.eval(max);\n\n            this._s = 0.5 * range * (minValue + maxValue);\n        }\n        else {\n            const iter = 1 << (n - 2);\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 0; i < iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            this._s = 0.5 * (this._s + range * sum / iter);\n        }\n\n        if (isNaN(this._s)) {\n            throw new Error(\"Polynomial.trapezoid: this._s is NaN\");\n        }\n\n        return this._s;\n    }\n\n    /**\n     *  simpson\n     *\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 139\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    simpson(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new Error(\"Polynomial.simpson: parameters must be numbers\");\n        }\n\n        const range = max - min;\n        let st = 0.5 * range * (this.eval(min) + this.eval(max));\n        let t = st;\n        let s = 4.0 * st / 3.0;\n        let os = s;\n        let ost = st;\n        const TOLERANCE = 1e-7;\n\n        let iter = 1;\n\n        for (let n = 2; n <= 20; n++) {\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 1; i <= iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            t = 0.5 * (t + range * sum / iter);\n            st = t;\n            s = (4.0 * st - ost) / 3.0;\n\n            if (Math.abs(s - os) < TOLERANCE * Math.abs(os)) {\n                break;\n            }\n\n            os = s;\n            ost = st;\n            iter <<= 1;\n        }\n\n        return s;\n    }\n\n    /**\n     *  romberg\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    romberg(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new Error(\"Polynomial.romberg: parameters must be numbers\");\n        }\n\n        const MAX = 20;\n        const K = 3;\n        const TOLERANCE = 1e-6;\n        const s = new Array(MAX + 1);\n        const h = new Array(MAX + 1);\n        let result = {y: 0, dy: 0};\n\n        h[0] = 1.0;\n\n        for (let j = 1; j <= MAX; j++) {\n            s[j - 1] = this.trapezoid(min, max, j);\n\n            if (j >= K) {\n                result = Polynomial.interpolate(h, s, K, j - K, 0.0);\n                if (Math.abs(result.dy) <= TOLERANCE * result.y) {\n                    break;\n                }\n            }\n\n            s[j] = s[j - 1];\n            h[j] = 0.25 * h[j - 1];\n        }\n\n        return result.y;\n    }\n\n    // getters and setters\n\n    /**\n     *  get degree\n     *\n     *  @returns {number}\n     */\n    getDegree() {\n        return this.coefs.length - 1;\n    }\n\n    /**\n     *  getDerivative\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    getDerivative() {\n        const derivative = new Polynomial();\n\n        for (let i = 1; i < this.coefs.length; i++) {\n            derivative.coefs.push(i * this.coefs[i]);\n        }\n\n        return derivative;\n    }\n\n    /**\n     *  getRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getRoots() {\n        let result;\n\n        this.simplify();\n\n        switch (this.getDegree()) {\n            case 0: result = []; break;\n            case 1: result = this.getLinearRoot(); break;\n            case 2: result = this.getQuadraticRoots(); break;\n            case 3: result = this.getCubicRoots(); break;\n            case 4: result = this.getQuarticRoots(); break;\n            default:\n                result = [];\n        }\n\n        return result;\n    }\n\n    /**\n     *  getRootsInInterval\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {Array<number>}\n     */\n    getRootsInInterval(min, max) {\n        const roots = [];\n\n        /**\n         *  @param {number} value\n         */\n        function push(value) {\n            if (typeof value === \"number\") {\n                roots.push(value);\n            }\n        }\n\n        if (this.getDegree() === 0) {\n            throw new Error(\"Polynomial.getRootsInInterval: Unexpected empty polynomial\");\n        }\n        else if (this.getDegree() === 1) {\n            push(this.bisection(min, max));\n        }\n        else {\n            // get roots of derivative\n            const deriv = this.getDerivative();\n            const droots = deriv.getRootsInInterval(min, max);\n\n            if (droots.length > 0) {\n                // find root on [min, droots[0]]\n                push(this.bisection(min, droots[0]));\n\n                // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2\n                for (let i = 0; i <= droots.length - 2; i++) {\n                    push(this.bisection(droots[i], droots[i + 1]));\n                }\n\n                // find root on [droots[count-1],xmax]\n                push(this.bisection(droots[droots.length - 1], max));\n            }\n            else {\n                // polynomial is monotone on [min,max], has at most one root\n                push(this.bisection(min, max));\n            }\n        }\n\n        return roots;\n    }\n\n    /**\n     *  getLinearRoot\n     *\n     *  @returns {number}\n     */\n    getLinearRoot() {\n        const result = [];\n        const a = this.coefs[1];\n\n        if (a !== 0) {\n            result.push(-this.coefs[0] / a);\n        }\n\n        return result;\n    }\n\n    /**\n     *  getQuadraticRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getQuadraticRoots() {\n        const results = [];\n\n        if (this.getDegree() === 2) {\n            const a = this.coefs[2];\n            const b = this.coefs[1] / a;\n            const c = this.coefs[0] / a;\n            const d = b * b - 4 * c;\n\n            if (d > 0) {\n                const e = Math.sqrt(d);\n\n                results.push(0.5 * (-b + e));\n                results.push(0.5 * (-b - e));\n            }\n            else if (d === 0) {\n                // really two roots with same value, but we only return one\n                results.push(0.5 * -b);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  getCubicRoots\n     *\n     *  This code is based on MgcPolynomial.cpp written by David Eberly.  His\n     *  code along with many other excellent examples are avaiable at his site:\n     *  http://www.geometrictools.com\n     *\n     *  @returns {Array<number>}\n     */\n    getCubicRoots() {\n        const results = [];\n\n        if (this.getDegree() === 3) {\n            const c3 = this.coefs[3];\n            const c2 = this.coefs[2] / c3;\n            const c1 = this.coefs[1] / c3;\n            const c0 = this.coefs[0] / c3;\n\n            const a = (3 * c1 - c2 * c2) / 3;\n            const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;\n            const offset = c2 / 3;\n            let discrim = b * b / 4 + a * a * a / 27;\n            const halfB = b / 2;\n\n            const ZEROepsilon = this.zeroErrorEstimate();\n\n            if (Math.abs(discrim) <= ZEROepsilon) {\n                discrim = 0;\n            }\n\n            if (discrim > 0) {\n                const e = Math.sqrt(discrim);\n                let root; // eslint-disable-line no-shadow\n\n                let tmp = -halfB + e;\n\n                if (tmp >= 0) {\n                    root = Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root = -Math.pow(-tmp, 1 / 3);\n                }\n\n                tmp = -halfB - e;\n\n                if (tmp >= 0) {\n                    root += Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root -= Math.pow(-tmp, 1 / 3);\n                }\n\n                results.push(root - offset);\n            }\n            else if (discrim < 0) {\n                const distance = Math.sqrt(-a / 3);\n                const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                const sqrt3 = Math.sqrt(3);\n\n                results.push(2 * distance * cos - offset);\n                results.push(-distance * (cos + sqrt3 * sin) - offset);\n                results.push(-distance * (cos - sqrt3 * sin) - offset);\n            }\n            else {\n                let tmp;\n\n                if (halfB >= 0) {\n                    tmp = -Math.pow(halfB, 1 / 3);\n                }\n                else {\n                    tmp = Math.pow(-halfB, 1 / 3);\n                }\n\n                results.push(2 * tmp - offset);\n                // really should return next root twice, but we return only one\n                results.push(-tmp - offset);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  Calculates roots of quartic polynomial. <br/>\n     *  First, derivative roots are found, then used to split quartic polynomial\n     *  into segments, each containing one root of quartic polynomial.\n     *  Segments are then passed to newton's method to find roots.\n     *\n     *  @returns {Array<number>} roots\n     */\n    getQuarticRoots() {\n        let results = [];\n        const n = this.getDegree();\n\n        if (n === 4) {\n            const poly = new Polynomial();\n\n            poly.coefs = this.coefs.slice();\n            poly.divide_scalar(poly.coefs[n]);\n\n            const ERRF = 1e-15;\n\n            if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3])) {\n                poly.coefs[0] = 0;\n            }\n\n            const poly_d = poly.getDerivative();\n            const derrt = poly_d.getRoots().sort((a, b) => a - b);\n            const dery = [];\n            const nr = derrt.length - 1;\n            const rb = this.bounds();\n\n            const maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n            const ZEROepsilon = this.zeroErrorEstimate(maxabsX);\n\n            for (let i = 0; i <= nr; i++) {\n                dery.push(poly.eval(derrt[i]));\n            }\n\n            for (let i = 0; i <= nr; i++) {\n                if (Math.abs(dery[i]) < ZEROepsilon) {\n                    dery[i] = 0;\n                }\n            }\n\n            let i = 0;\n            const dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);\n            const guesses = [];\n            const minmax = [];\n\n            if (nr > -1) {\n                if (dery[0] !== 0) {\n                    if (sign(dery[0]) !== sign(poly.eval(derrt[0] - dx) - dery[0])) {\n                        guesses.push(derrt[0] - dx);\n                        minmax.push([rb.minX, derrt[0]]);\n                    }\n                }\n                else {\n                    results.push(derrt[0], derrt[0]);\n                    i++;\n                }\n\n                for (; i < nr; i++) {\n                    if (dery[i + 1] === 0) {\n                        results.push(derrt[i + 1], derrt[i + 1]);\n                        i++;\n                    }\n                    else if (sign(dery[i]) !== sign(dery[i + 1])) {\n                        guesses.push((derrt[i] + derrt[i + 1]) / 2);\n                        minmax.push([derrt[i], derrt[i + 1]]);\n                    }\n                }\n                if (dery[nr] !== 0 && sign(dery[nr]) !== sign(poly.eval(derrt[nr] + dx) - dery[nr])) {\n                    guesses.push(derrt[nr] + dx);\n                    minmax.push([derrt[nr], rb.maxX]);\n                }\n            }\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const f = function(x) {\n                return poly.eval(x);\n            };\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const df = function(x) {\n                return poly_d.eval(x);\n            };\n\n            if (guesses.length > 0) {\n                for (i = 0; i < guesses.length; i++) {\n                    guesses[i] = Polynomial.newton_secant_bisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);\n                }\n            }\n\n            results = results.concat(guesses);\n        }\n\n        return results;\n    }\n\n    /**\n     *  Estimate what is the maximum polynomial evaluation error value under which polynomial evaluation could be in fact 0.\n     *\n     *  @param {number} maxabsX\n     *  @returns {number}\n     */\n    zeroErrorEstimate(maxabsX) {\n        const poly = this;\n        const ERRF = 1e-15;\n\n        if (typeof maxabsX === \"undefined\") {\n            const rb = poly.bounds();\n\n            maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n        }\n\n        if (maxabsX < 0.001) {\n            return 2 * Math.abs(poly.eval(ERRF));\n        }\n\n        const n = poly.coefs.length - 1;\n        const an = poly.coefs[n];\n\n        return 10 * ERRF * poly.coefs.reduce((m, v, i) => {\n            const nm = v / an * Math.pow(maxabsX, i);\n            return nm > m ? nm : m;\n        }, 0);\n    }\n\n    /**\n     *  Calculates upper Real roots bounds. <br/>\n     *  Real roots are in interval [negX, posX]. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    bounds_UpperReal_Fujiwara() {\n        let a = this.coefs;\n        const n = a.length - 1;\n        const an = a[n];\n\n        if (an !== 1) {\n            a = this.coefs.map(v => v / an);\n        }\n\n        const b = a.map((v, i) => {\n            return (i < n)\n                ? Math.pow(Math.abs((i === 0) ? v / 2 : v), 1 / (n - i))\n                : v;\n        });\n\n        let coefSelectionFunc;\n        const find2Max = function(acc, bi, i) {\n            if (coefSelectionFunc(i)) {\n                if (acc.max < bi) {\n                    acc.nearmax = acc.max;\n                    acc.max = bi;\n                }\n                else if (acc.nearmax < bi) {\n                    acc.nearmax = bi;\n                }\n            }\n            return acc;\n        };\n\n        coefSelectionFunc = function(i) {\n            return i < n && a[i] < 0;\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_pos = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        coefSelectionFunc = function(i) {\n            return i < n && ((n % 2 === i % 2) ? a[i] < 0 : a[i] > 0);\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_neg = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        return {\n            negX: -2 * max_nearmax_neg.max,\n            posX: 2 * max_nearmax_pos.max\n        };\n    }\n\n    /**\n     *  Calculates lower Real roots bounds. <br/>\n     *  There are no Real roots in interval <negX, posX>. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    bounds_LowerReal_Fujiwara() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice().reverse();\n\n        const res = poly.bounds_UpperReal_Fujiwara();\n\n        res.negX = 1 / res.negX;\n        res.posX = 1 / res.posX;\n\n        return res;\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  Real roots are in interval [minX, maxX]. Combines Fujiwara lower and upper bounds to get minimal interval.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n    */\n    bounds() {\n        const urb = this.bounds_UpperReal_Fujiwara();\n        const rb = {minX: urb.negX, maxX: urb.posX};\n\n        if (urb.negX === 0 && urb.posX === 0) {\n            return rb;\n        }\n\n        if (urb.negX === 0) {\n            rb.minX = this.bounds_LowerReal_Fujiwara().posX;\n        }\n        else if (urb.posX === 0) {\n            rb.maxX = this.bounds_LowerReal_Fujiwara().negX;\n        }\n\n        if (rb.minX > rb.maxX) {\n            rb.minX = rb.maxX = 0;\n        }\n\n        return rb;\n        // TODO: if sure that there are no complex roots\n        // (maybe by using Sturm's theorem) use:\n        // return this.bounds_Real_Laguerre();\n    }\n\n    /**\n     *  Sets small coefficients to zero.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    modify_zeroSmallCoefs() {\n        const c = this.coefs;\n        const ERRF = 1e-15;\n        const err = 10 * ERRF * Math.abs(\n            c.reduce((pv, cv) => {\n                return Math.abs(cv) > Math.abs(pv) ? cv : pv;\n            })\n        );\n\n        for (let i = 0; i < c.length - 1; i++) {\n            if (Math.abs(c[i]) < err) {\n                c[i] = 0;\n            }\n        }\n\n        return this;\n    }\n\n\n    /**\n     *  Scales polynomial so that leading coefficient becomes 1.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    modify_toMonic() {\n        const c = this.coefs;\n\n        if (c[c.length - 1] !== 1) {\n            this.divide_scalar(c[c.length - 1]);\n        }\n\n        return this;\n    }\n\n\n    /**\n     *  Calculates absolute upper roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &lt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *  @returns {number}\n     */\n    bound_UpperAbs_Rouche() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== n) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return 1 + max / Math.abs(a[n]);\n    }\n\n\n    /**\n     *  Calculates absolute lower roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &gt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *  @returns {number}\n     */\n    bound_LowerAbs_Rouche() {\n        const a = this.coefs;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== 0) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return Math.abs(a[0]) / (Math.abs(a[0]) + max);\n    }\n\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  WORKS ONLY if all polynomial roots are Real.\n     *  Real roots are in interval [minX, maxX]. Determined by Laguerre method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *  @returns {{ minX: number, maxX: number }}\n     */\n    bounds_Real_Laguerre() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const p1 = -a[n - 1] / (n * a[n]);\n        const undersqrt = a[n - 1] * a[n - 1] - 2 * n / (n - 1) * a[n] * a[n - 2];\n        let p2 = (n - 1) / (n * a[n]) * Math.sqrt(undersqrt);\n\n        if (p2 < 0) {\n            p2 = -p2;\n        }\n\n        return {\n            minX: p1 - p2,\n            maxX: p1 + p2\n        };\n    }\n\n\n    /**\n     *  Root count by Descartes rule of signs. <br/>\n     *  Returns maximum number of positive and negative real roots and minimum number of complex roots.\n     *  @see {@link http://en.wikipedia.org/wiki/Descartes%27_rule_of_signs}\n     *  @returns {{maxRealPos: number, maxRealNeg: number, minComplex: number}}\n     */\n    countRoots_Descartes() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const accum = a.reduce((acc, ai, i) => {\n            if (acc.prev_a !== 0 && ai !== 0) {\n                if ((acc.prev_a < 0) === (ai > 0)) {\n                    acc.pos++;\n                }\n                if (((i % 2 === 0) !== (acc.prev_a < 0)) === ((i % 2 === 1) !== (ai > 0))) {\n                    acc.neg++;\n                }\n            }\n            acc.prev_a = ai;\n            return acc;\n        }, {pos: 0, neg: 0, prev_a: 0});\n\n        return {\n            maxRealPos: accum.pos,\n            maxRealNeg: accum.neg,\n            minComplex: n - (accum.pos + accum.neg)\n        };\n    }\n}\n\nPolynomial.TOLERANCE = 1e-6;\nPolynomial.ACCURACY = 15;\n\nexport default Polynomial;\n","/**\n *  SqrtPolynomial.js\n *\n *  @module SqrtPolynomial\n *  @copyright 2002-2019 Kevin Lindsey\n */\n\nimport Polynomial from \"./Polynomial.js\";\n\n\n/**\n *  SqrtPolynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass SqrtPolynomial extends Polynomial {\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     *  @returns {number}\n     */\n    eval(x) {\n        const TOLERANCE = 1e-7;\n\n        let result = super.eval(x);\n\n        // NOTE: May need to change the following.  I added these to capture\n        // some really small negative values that were being generated by one\n        // of my Bezier arcLength functions\n        if (Math.abs(result) < TOLERANCE) {\n            result = 0;\n        }\n\n        if (result < 0) {\n            throw new Error(\"SqrtPolynomial.eval: cannot take square root of negative number\");\n        }\n\n        return Math.sqrt(result);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const result = super.toString();\n\n        return \"sqrt(\" + result + \")\";\n    }\n}\n\nexport default SqrtPolynomial;\n","/**\n *  Point2D.js\n *  @module Point2D\n *  @copyright 2001-2019 Kevin Lindsey\n */\n\n/**\n *  Point2D\n *\n *  @memberof module:kld-affine\n */\nclass Point2D {\n    /**\n     *  Point2D\n     *\n     *  @param {number} x\n     *  @param {number} y\n     *  @returns {module:kld-affine.Point2D}\n     */\n    constructor(x, y) {\n        this.x = x !== undefined ? x : 0.0;\n        this.y = y !== undefined ? y : 0.0;\n    }\n\n    /**\n     *  clone\n     *\n     *  @returns {module:kld-affine.Point2D}\n     */\n    clone() {\n        return new this.constructor(this.x, this.y);\n    }\n\n    /**\n     *  add\n     *\n     *  @param {Point2D|Vector2D} that\n     *  @returns {module:kld-affine.Point2D}\n     */\n    add(that) {\n        return new this.constructor(this.x + that.x, this.y + that.y);\n    }\n\n    /**\n     *  subtract\n     *\n     *  @param { Vector2D | Point2D } that\n     *  @returns {module:kld-affine.Point2D}\n     */\n    subtract(that) {\n        return new this.constructor(this.x - that.x, this.y - that.y);\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Point2D}\n     */\n    multiply(scalar) {\n        return new this.constructor(this.x * scalar, this.y * scalar);\n    }\n\n    /**\n     *  divide\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Point2D}\n     */\n    divide(scalar) {\n        return new this.constructor(this.x / scalar, this.y / scalar);\n    }\n\n    /**\n     *  equals\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {boolean}\n     */\n    equals(that) {\n        return (this.x === that.x && this.y === that.y);\n    }\n\n    /**\n     *  precisionEquals\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @param {number} precision\n     *  @returns {boolean}\n     */\n    precisionEquals(that, precision) {\n        return (\n            Math.abs(this.x - that.x) < precision &&\n            Math.abs(this.y - that.y) < precision\n        );\n    }\n\n    // utility methods\n\n    /**\n     *  lerp\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @param {number} t\n     *  @returns {module:kld-affine.Point2D}\n     */\n    lerp(that, t) {\n        const omt = 1.0 - t;\n\n        return new this.constructor(\n            this.x * omt + that.x * t,\n            this.y * omt + that.y * t\n        );\n    }\n\n    /**\n     *  distanceFrom\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {number}\n     */\n    distanceFrom(that) {\n        const dx = this.x - that.x;\n        const dy = this.y - that.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     *  min\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {number}\n     */\n    min(that) {\n        return new this.constructor(\n            Math.min(this.x, that.x),\n            Math.min(this.y, that.y)\n        );\n    }\n\n    /**\n     *  max\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {number}\n     */\n    max(that) {\n        return new this.constructor(\n            Math.max(this.x, that.x),\n            Math.max(this.y, that.y)\n        );\n    }\n\n    /**\n     *  transform\n     *\n     *  @param {module:kld-affine.Matrix2D} matrix\n     *  @returns {module:kld-affine.Point2D}\n     */\n    transform(matrix) {\n        return new this.constructor(\n            matrix.a * this.x + matrix.c * this.y + matrix.e,\n            matrix.b * this.x + matrix.d * this.y + matrix.f\n        );\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return \"point(\" + this.x + \",\" + this.y + \")\";\n    }\n}\n\nexport default Point2D;\n","/**\n *  Vector2D.js\n *  @module Vector2D\n *  @copyright 2001-2019 Kevin Lindsey\n */\n\n/**\n *  Vector2D\n *\n *  @memberof module:kld-affine\n */\nclass Vector2D {\n    /**\n     *  Vector2D\n     *\n     *  @param {number} x\n     *  @param {number} y\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    constructor(x, y) {\n        this.x = x !== undefined ? x : 0.0;\n        this.y = y !== undefined ? y : 0.0;\n    }\n\n    /**\n     *  fromPoints\n     *\n     *  @param {module:kld-affine.Point2D} p1\n     *  @param {module:kld-affine.Point2D} p2\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    static fromPoints(p1, p2) {\n        return new Vector2D(\n            p2.x - p1.x,\n            p2.y - p1.y\n        );\n    }\n\n    /**\n     *  length\n     *\n     *  @returns {number}\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    /**\n     *  magnitude\n     *\n     *  @returns {number}\n     */\n    magnitude() {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    /**\n     *  dot\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    dot(that) {\n        return this.x * that.x + this.y * that.y;\n    }\n\n    /**\n     *  cross\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    cross(that) {\n        return this.x * that.y - this.y * that.x;\n    }\n\n    /**\n     *  determinant\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    determinant(that) {\n        return this.x * that.y - this.y * that.x;\n    }\n\n    /**\n     *  unit\n     *\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    unit() {\n        return this.divide(this.length());\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    add(that) {\n        return new this.constructor(this.x + that.x, this.y + that.y);\n    }\n\n    /**\n     *  subtract\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    subtract(that) {\n        return new this.constructor(this.x - that.x, this.y - that.y);\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    multiply(scalar) {\n        return new this.constructor(this.x * scalar, this.y * scalar);\n    }\n\n    /**\n     *  divide\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    divide(scalar) {\n        return new this.constructor(this.x / scalar, this.y / scalar);\n    }\n\n    /**\n     *  angleBetween\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    angleBetween(that) {\n        let cos = this.dot(that) / (this.length() * that.length());\n        cos = Math.max(-1, Math.min(cos, 1));\n        const radians = Math.acos(cos);\n\n        return (this.cross(that) < 0.0) ? -radians : radians;\n    }\n\n    /**\n     *  Find a vector is that is perpendicular to this vector\n     *\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    perp() {\n        return new this.constructor(-this.y, this.x);\n    }\n\n    /**\n     *  Find the component of the specified vector that is perpendicular to\n     *  this vector\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    perpendicular(that) {\n        return this.subtract(this.project(that));\n    }\n\n    /**\n     *  project\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    project(that) {\n        const percent = this.dot(that) / that.dot(that);\n\n        return that.multiply(percent);\n    }\n\n    /**\n     *  transform\n     *\n     *  @param {module:kld-affine.Matrix2D} matrix\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    transform(matrix) {\n        return new this.constructor(\n            matrix.a * this.x + matrix.c * this.y,\n            matrix.b * this.x + matrix.d * this.y\n        );\n    }\n\n    /**\n     *  equals\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {boolean}\n     */\n    equals(that) {\n        return (\n            this.x === that.x &&\n            this.y === that.y\n        );\n    }\n\n    /**\n     *  precisionEquals\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @param {number} precision\n     *  @returns {boolean}\n     */\n    precisionEquals(that, precision) {\n        return (\n            Math.abs(this.x - that.x) < precision &&\n            Math.abs(this.y - that.y) < precision\n        );\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return \"vector(\" + this.x + \",\" + this.y + \")\";\n    }\n}\n\nexport default Vector2D;\n","/**\n *  Matrix2D.js\n *  @module Matrix2D\n *  @copyright 2001-2019 Kevin Lindsey\n */\n\n/**\n *  Matrix2D\n *\n *  @memberof module:kld-affine\n */\nclass Matrix2D {\n    /**\n     *  Matrix2D\n     *\n     *  [a c e]\n     *  [b d f]\n     *  [0 0 1]\n     *\n     *  @param {number} a\n     *  @param {number} b\n     *  @param {number} c\n     *  @param {number} d\n     *  @param {number} e\n     *  @param {number} f\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    constructor(a, b, c, d, e, f) {\n        this.a = (a !== undefined) ? a : 1;\n        this.b = (b !== undefined) ? b : 0;\n        this.c = (c !== undefined) ? c : 0;\n        this.d = (d !== undefined) ? d : 1;\n        this.e = (e !== undefined) ? e : 0;\n        this.f = (f !== undefined) ? f : 0;\n    }\n\n    /**\n     *  translation\n     *\n     *  @param {number} tx\n     *  @param {number} ty\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static translation(tx, ty) {\n        return new Matrix2D(1, 0, 0, 1, tx, ty);\n    }\n\n    /**\n     *  scaling\n     *\n     *  @param {number} scale\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static scaling(scale) {\n        return new Matrix2D(scale, 0, 0, scale, 0, 0);\n    }\n\n    /**\n     *  scalingAt\n     *\n     *  @param {number} scale\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static scalingAt(scale, center) {\n        return new Matrix2D(\n            scale,\n            0,\n            0,\n            scale,\n            center.x - center.x * scale,\n            center.y - center.y * scale\n        );\n    }\n\n\n    /**\n     *  nonUniformScaling\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static nonUniformScaling(scaleX, scaleY) {\n        return new Matrix2D(scaleX, 0, 0, scaleY, 0, 0);\n    }\n\n    /**\n     *  nonUniformScalingAt\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static nonUniformScalingAt(scaleX, scaleY, center) {\n        return new Matrix2D(\n            scaleX,\n            0,\n            0,\n            scaleY,\n            center.x - center.x * scaleX,\n            center.y - center.y * scaleY\n        );\n    }\n\n    /**\n     *  rotation\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static rotation(radians) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n\n        return new Matrix2D(c, s, -s, c, 0, 0);\n    }\n\n    /**\n     *  rotationAt\n     *\n     *  @param {number} radians\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static rotationAt(radians, center) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n\n        return new Matrix2D(\n            c,\n            s,\n            -s,\n            c,\n            center.x - center.x * c + center.y * s,\n            center.y - center.y * c - center.x * s\n        );\n    }\n\n    /**\n     *  rotationFromVector\n     *\n     *  @param {module:kld-affine.Vector2D} vector\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static rotationFromVector(vector) {\n        const unit = vector.unit();\n        const c = unit.x; // cos\n        const s = unit.y; // sin\n\n        return new Matrix2D(c, s, -s, c, 0, 0);\n    }\n\n    /**\n     *  xFlip\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static xFlip() {\n        return new Matrix2D(-1, 0, 0, 1, 0, 0);\n    }\n\n    /**\n     *  yFlip\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static yFlip() {\n        return new Matrix2D(1, 0, 0, -1, 0, 0);\n    }\n\n    /**\n     *  xSkew\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static xSkew(radians) {\n        const t = Math.tan(radians);\n\n        return new Matrix2D(1, 0, t, 1, 0, 0);\n    }\n\n    /**\n     *  ySkew\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static ySkew(radians) {\n        const t = Math.tan(radians);\n\n        return new Matrix2D(1, t, 0, 1, 0, 0);\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-affine.Matrix2D} that\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    multiply(that) {\n        if (this.isIdentity()) {\n            return that;\n        }\n\n        if (that.isIdentity()) {\n            return this;\n        }\n\n        return new this.constructor(\n            this.a * that.a + this.c * that.b,\n            this.b * that.a + this.d * that.b,\n            this.a * that.c + this.c * that.d,\n            this.b * that.c + this.d * that.d,\n            this.a * that.e + this.c * that.f + this.e,\n            this.b * that.e + this.d * that.f + this.f\n        );\n    }\n\n    /**\n     *  inverse\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    inverse() {\n        if (this.isIdentity()) {\n            return this;\n        }\n\n        const det1 = this.a * this.d - this.b * this.c;\n\n        if (det1 === 0.0) {\n            throw new Error(\"Matrix is not invertible\");\n        }\n\n        const idet = 1.0 / det1;\n        const det2 = this.f * this.c - this.e * this.d;\n        const det3 = this.e * this.b - this.f * this.a;\n\n        return new this.constructor(\n            this.d * idet,\n            -this.b * idet,\n            -this.c * idet,\n            this.a * idet,\n            det2 * idet,\n            det3 * idet\n        );\n    }\n\n    /**\n     *  translate\n     *\n     *  @param {number} tx\n     *  @param {number} ty\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    translate(tx, ty) {\n        return new this.constructor(\n            this.a,\n            this.b,\n            this.c,\n            this.d,\n            this.a * tx + this.c * ty + this.e,\n            this.b * tx + this.d * ty + this.f\n        );\n    }\n\n    /**\n     *  scale\n     *\n     *  @param {number} scale\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scale(scale) {\n        return new this.constructor(\n            this.a * scale,\n            this.b * scale,\n            this.c * scale,\n            this.d * scale,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  scaleAt\n     *\n     *  @param {number} scale\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scaleAt(scale, center) {\n        const dx = center.x - scale * center.x;\n        const dy = center.y - scale * center.y;\n\n        return new this.constructor(\n            this.a * scale,\n            this.b * scale,\n            this.c * scale,\n            this.d * scale,\n            this.a * dx + this.c * dy + this.e,\n            this.b * dx + this.d * dy + this.f\n        );\n    }\n\n    /**\n     *  scaleNonUniform\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scaleNonUniform(scaleX, scaleY) {\n        return new this.constructor(\n            this.a * scaleX,\n            this.b * scaleX,\n            this.c * scaleY,\n            this.d * scaleY,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  scaleNonUniformAt\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scaleNonUniformAt(scaleX, scaleY, center) {\n        const dx = center.x - scaleX * center.x;\n        const dy = center.y - scaleY * center.y;\n\n        return new this.constructor(\n            this.a * scaleX,\n            this.b * scaleX,\n            this.c * scaleY,\n            this.d * scaleY,\n            this.a * dx + this.c * dy + this.e,\n            this.b * dx + this.d * dy + this.f\n        );\n    }\n\n    /**\n     *  rotate\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    rotate(radians) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n\n        return new this.constructor(\n            this.a * c + this.c * s,\n            this.b * c + this.d * s,\n            this.a * -s + this.c * c,\n            this.b * -s + this.d * c,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  rotateAt\n     *\n     *  @param {number} radians\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    rotateAt(radians, center) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        const cx = center.x;\n        const cy = center.y;\n\n        const a = this.a * cos + this.c * sin;\n        const b = this.b * cos + this.d * sin;\n        const c = this.c * cos - this.a * sin;\n        const d = this.d * cos - this.b * sin;\n\n        return new this.constructor(\n            a,\n            b,\n            c,\n            d,\n            (this.a - a) * cx + (this.c - c) * cy + this.e,\n            (this.b - b) * cx + (this.d - d) * cy + this.f\n        );\n    }\n\n    /**\n     *  rotateFromVector\n     *\n     *  @param {module:kld-affine.Vector2D} vector\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    rotateFromVector(vector) {\n        const unit = vector.unit();\n        const c = unit.x; // cos\n        const s = unit.y; // sin\n\n        return new this.constructor(\n            this.a * c + this.c * s,\n            this.b * c + this.d * s,\n            this.a * -s + this.c * c,\n            this.b * -s + this.d * c,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  flipX\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    flipX() {\n        return new this.constructor(\n            -this.a,\n            -this.b,\n            this.c,\n            this.d,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  flipY\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    flipY() {\n        return new this.constructor(\n            this.a,\n            this.b,\n            -this.c,\n            -this.d,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  skewX\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    skewX(radians) {\n        const t = Math.tan(radians);\n\n        return new this.constructor(\n            this.a,\n            this.b,\n            this.c + this.a * t,\n            this.d + this.b * t,\n            this.e,\n            this.f\n        );\n    }\n\n    // TODO: skewXAt\n\n    /**\n     *  skewY\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    skewY(radians) {\n        const t = Math.tan(radians);\n\n        return new this.constructor(\n            this.a + this.c * t,\n            this.b + this.d * t,\n            this.c,\n            this.d,\n            this.e,\n            this.f\n        );\n    }\n\n    // TODO: skewYAt\n\n    /**\n     *  isIdentity\n     *\n     *  @returns {boolean}\n     */\n    isIdentity() {\n        return (\n            this.a === 1.0 &&\n            this.b === 0.0 &&\n            this.c === 0.0 &&\n            this.d === 1.0 &&\n            this.e === 0.0 &&\n            this.f === 0.0\n        );\n    }\n\n    /**\n     *  isInvertible\n     *\n     *  @returns {boolean}\n     */\n    isInvertible() {\n        return this.a * this.d - this.b * this.c !== 0.0;\n    }\n\n    /**\n     *  getScale\n     *\n     *  @returns {{ scaleX: number, scaleY: number }}\n     */\n    getScale() {\n        return {\n            scaleX: Math.sqrt(this.a * this.a + this.c * this.c),\n            scaleY: Math.sqrt(this.b * this.b + this.d * this.d)\n        };\n    }\n\n    /**\n     *  getDecomposition\n     *\n     *  Calculates matrix Singular Value Decomposition\n     *\n     *  The resulting matrices, translation, rotation, scale, and rotation0, return\n     *  this matrix when they are muliplied together in the listed order\n     *\n     *  @see Jim Blinn's article {@link http://dx.doi.org/10.1109/38.486688}\n     *  @see {@link http://math.stackexchange.com/questions/861674/decompose-a-2d-arbitrary-transform-into-only-scaling-and-rotation}\n     *\n     *  @returns {{ translation: module:kld-affine.Matrix2D, rotation: module:kld-affine.Matrix2D, scale: module:kld-affine.Matrix2D, rotation0: module:kld-affine.Matrix2D }}\n     */\n    getDecomposition() {\n        const E = (this.a + this.d) * 0.5;\n        const F = (this.a - this.d) * 0.5;\n        const G = (this.b + this.c) * 0.5;\n        const H = (this.b - this.c) * 0.5;\n\n        const Q = Math.sqrt(E * E + H * H);\n        const R = Math.sqrt(F * F + G * G);\n        const scaleX = Q + R;\n        const scaleY = Q - R;\n\n        const a1 = Math.atan2(G, F);\n        const a2 = Math.atan2(H, E);\n        const theta = (a2 - a1) * 0.5;\n        const phi = (a2 + a1) * 0.5;\n\n        return {\n            translation: this.constructor.translation(this.e, this.f),\n            rotation: this.constructor.rotation(phi),\n            scale: this.constructor.nonUniformScaling(scaleX, scaleY),\n            rotation0: this.constructor.rotation(theta)\n        };\n    }\n\n    /**\n     *  equals\n     *\n     *  @param {module:kld-affine.Matrix2D} that\n     *  @returns {boolean}\n     */\n    equals(that) {\n        return (\n            this.a === that.a &&\n            this.b === that.b &&\n            this.c === that.c &&\n            this.d === that.d &&\n            this.e === that.e &&\n            this.f === that.f\n        );\n    }\n\n    /**\n     *  precisionEquals\n     *\n     *  @param {module:kld-affine.Matrix2D} that\n     *  @param {number} precision\n     *  @returns {boolean}\n     */\n    precisionEquals(that, precision) {\n        return (\n            Math.abs(this.a - that.a) < precision &&\n            Math.abs(this.b - that.b) < precision &&\n            Math.abs(this.c - that.c) < precision &&\n            Math.abs(this.d - that.d) < precision &&\n            Math.abs(this.e - that.e) < precision &&\n            Math.abs(this.f - that.f) < precision\n        );\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return \"matrix(\" + [this.a, this.b, this.c, this.d, this.e, this.f].join(\",\") + \")\";\n    }\n}\n\n/**\n *  Identity matrix\n *\n *  @returns {module:kld-affine.Matrix2D}\n */\nMatrix2D.IDENTITY = new Matrix2D();\nMatrix2D.IDENTITY.isIdentity = () => true;\n\n\nexport default Matrix2D;\n","/**\n *  CubicBezier2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module CubicBezier2D\n */\nimport {Polynomial, SqrtPolynomial} from \"kld-polynomial\";\nimport {Matrix2D, Point2D, Vector2D} from \"kld-affine\";\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  CubicBezier2D\n */\nclass CubicBezier2D {\n    /**\n     *  @param {module:kld-affine.Point2D} p1\n     *  @param {module:kld-affine.Point2D} p2\n     *  @param {module:kld-affine.Point2D} p3\n     *  @param {module:kld-affine.Point2D} p4\n     *  @returns {module:kld-contours~CubicBezier2D}\n     */\n    constructor(p1, p2, p3, p4) {\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n        this.p4 = p4;\n    }\n\n    /**\n     *  getPointAtParameter\n     *\n     *  @param {number} t\n     *  @returns {module:kld-affine.Point2D}\n     */\n    getPointAtParameter(t) {\n        // TODO: validate t in [0,1]\n\n        // first round of lerps\n        const p5 = this.p1.lerp(this.p2, t);\n        const p6 = this.p2.lerp(this.p3, t);\n        const p7 = this.p3.lerp(this.p4, t);\n\n        // second round of lerps\n        const p8 = p5.lerp(p6, t);\n        const p9 = p6.lerp(p7, t);\n\n        return p8.lerp(p9, t);\n    }\n\n    /**\n     *  splitAtParameter\n     *\n     *  @param {number} t\n     *  @returns {Array<module:kld-contours~CubicBezier2D>}\n     */\n    splitAtParameter(t) {\n        // first round of lerps\n        const p5 = this.p1.lerp(this.p2, t);\n        const p6 = this.p2.lerp(this.p3, t);\n        const p7 = this.p3.lerp(this.p4, t);\n\n        // second round of lerps\n        const p8 = p5.lerp(p6, t);\n        const p9 = p6.lerp(p7, t);\n\n        // third round of lerps\n        const p10 = p8.lerp(p9, t);\n\n        return [\n            new CubicBezier2D(this.p1, p5, p8, p10),\n            new CubicBezier2D(p10, p9, p7, this.p4)\n        ];\n    }\n\n    /**\n     *  getBernsteinPolynomials\n     *\n     *  @returns {{x: module:kld-polynomial.Polynomial, y: module:kld-polynomial.Polynomial}}\n     */\n    getBernsteinPolynomials() {\n        let a, b, c;\n\n        // Start with Bezier using Bernstein polynomials for weighting functions:\n        //     (1-t^3)P1 + 3t(1-t)^2P2 + 3t^2(1-t)P3 + t^3P4\n        //\n        // Expand and collect terms to form linear combinations of original Bezier\n        // controls.  This ends up with a vector cubic in t:\n        //     (-P1+3P2-3P3+P4)t^3 + (3P1-6P2+3P3)t^2 + (-3P1+3P2)t + P1\n        //             /\\                  /\\                /\\       /\\\n        //             ||                  ||                ||       ||\n        //             c3                  c2                c1       c0\n\n        // Calculate the coefficients\n        a = this.p1.multiply(-1);\n        b = this.p2.multiply(3);\n        c = this.p3.multiply(-3);\n        const c3 = a.add(b.add(c.add(this.p4)));\n\n        a = this.p1.multiply(3);\n        b = this.p2.multiply(-6);\n        c = this.p3.multiply(3);\n        const c2 = a.add(b.add(c));\n\n        a = this.p1.multiply(-3);\n        b = this.p2.multiply(3);\n        const c1 = a.add(b);\n\n        const c0 = this.p1;\n\n        return {\n            x: new Polynomial(c3.x, c2.x, c1.x, c0.x),\n            y: new Polynomial(c3.y, c2.y, c1.y, c0.y)\n        };\n    }\n\n    /**\n     *  getArcLengthPolynomial\n     *\n     *  @returns {module:kld-polynomial.SqrtPolynomial}\n     */\n    getArcLengthPolynomial() {\n        // TODO: use Object.defineProperty\n        // TODO: use results from getBernsteinPolynomials but need getCoeficent in\n        // Polynomial first\n\n        /* eslint-disable-next-line no-prototype-builtins */\n        if (!this.hasOwnProperty(\"arcLengthPolynomial\")) {\n            let a, b, c;\n\n            // convert to Bernstein polynomials\n            a = this.p1.multiply(-1);\n            b = this.p2.multiply(3);\n            c = this.p3.multiply(-3);\n            const c3 = a.add(b.add(c.add(this.p4)));\n\n            a = this.p1.multiply(3);\n            b = this.p2.multiply(-6);\n            c = this.p3.multiply(3);\n            const c2 = a.add(b.add(c));\n\n            a = this.p1.multiply(-3);\n            b = this.p2.multiply(3);\n            const c1 = a.add(b);\n\n            //  ____________\n            //  dx^2 + dy^2\n            //\n            this.arcLengthPolynomial = new SqrtPolynomial(\n                9 * (c3.x * c3.x + c3.y * c3.y),\n                12 * (c2.x * c3.x + c2.y * c3.y),\n                4 * (c2.x * c2.x + c2.y * c2.y) + 6 * (c1.x * c3.x + c1.y * c3.y),\n                4 * (c1.x * c2.x + c1.y * c2.y),\n                c1.x * c1.x + c1.y * c1.y\n            );\n\n            this.arcLength = this.arcLengthPolynomial.romberg(0, 1);\n            // this.arcLength = this.arcLengthPolynomial.simpson(0, 1);\n        }\n\n        return this.arcLengthPolynomial;\n    }\n\n    /**\n     *  getParameterFromArcLength\n     *\n     *  @param {number} arcLength\n     *  @returns {number}\n     */\n    getParameterFromArcLength(arcLength) {\n        // TODO: extract common Bezier code\n\n        // make sure the arc length polynomial and arc length values have been calculated\n        const arcLengthPolynomial = this.getArcLengthPolynomial();\n        let result;\n\n        if (arcLength <= 0) {\n            result = 0;\n        }\n        else if (arcLength >= this.arcLength) {\n            result = 1;\n        }\n        else {\n            const TOLERANCE = 1e-9;\n            const MAXITERS = 20;\n\n            result = arcLength / this.arcLength;\n\n            for (let i = 0; i <= MAXITERS; i++) {\n                const diff = arcLengthPolynomial.romberg(0, result) - arcLength;\n\n                if (Math.abs(diff) < TOLERANCE) {\n                    break;\n                }\n\n                const value = arcLengthPolynomial.eval(result);\n\n                if (value === 0) {\n                    break;\n                }\n\n                result -= diff / value;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        const polys = this.getBernsteinPolynomials();\n        const dx = polys.x.getDerivative();\n        const dy = polys.y.getDerivative();\n        let roots = dx.getRootsInInterval(0, 1);\n\n        roots = roots.concat(dy.getRootsInInterval(0, 1));\n\n        // initialize min/max using the first and last points on the curve\n        let min = this.p1.min(this.p4);\n        let max = this.p1.max(this.p4);\n\n        // and now update min/max with points between p1 and p4\n        roots.forEach(function(t) {\n            if (0 <= t && t <= 1) {\n                const testPoint = new Point2D(\n                    polys.x.eval(t),\n                    polys.y.eval(t)\n                );\n\n                min = min.min(testPoint);\n                max = max.max(testPoint);\n            }\n        });\n\n        return new BoundingBox2D(\n            min.x,\n            min.y,\n            max.x - min.x,\n            max.y - min.y\n        );\n    }\n\n    /**\n     *  getAlignedBoundingBox\n     *\n     *  @returns {{ bbox: module:kld-contours~BoundingBox2D, transform: module:kld-affine.Matrix2D }}\n     */\n    getAlignedBoundingBox() {\n        return {\n            bbox: this.getAlignedBezier().getBoundingBox(),\n            transform: new Matrix2D()\n                .translation(this.p1.x, this.p1.y)\n                .rotateFromVector(Vector2D.fromPoints(this.p1, this.p4))\n        };\n    }\n\n    /**\n     *  getAlignedBezier\n     *\n     *  @returns {module:kld-contours~CubicBezier2D}\n     */\n    getAlignedBezier() {\n        const matrix = Matrix2D\n            .translation(this.p1.x, this.p1.y) // move p1 to the origin\n            .rotateFromVector(Vector2D.fromPoints(this.p1, this.p4)) // rotate vector from p1 to p4 to x-axis\n            .inverse(); // reverse transforms\n\n        // apply to each point and create new Bezier\n        return new CubicBezier2D(\n            this.p1.transform(matrix),\n            this.p2.transform(matrix),\n            this.p3.transform(matrix),\n            this.p4.transform(matrix)\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @param {number} [flatness]\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D(flatness) {\n        const points = [];\n        const zeroVector = new Vector2D(0, 0);\n\n        flatness = flatness !== undefined ? flatness : 1.0;\n\n        // add first point\n        points.push(this.p1);\n\n        // add middle points\n        /**\n         *  @param {number} p1\n         *  @param {number} p2\n         *  @param {number} p3\n         *  @param {number} p4\n         */\n        function tesselateInterior(p1, p2, p3, p4) {\n            // round 1\n            const p5 = p1.lerp(p2, 0.5);\n            const p6 = p2.lerp(p3, 0.5);\n            const p7 = p3.lerp(p4, 0.5);\n\n            // round 2\n            const p8 = p5.lerp(p6, 0.5);\n            const p9 = p6.lerp(p7, 0.5);\n\n            // round 3\n            const p10 = p8.lerp(p9, 0.5);\n\n            const baseline = Vector2D.fromPoints(p1, p4);\n            const tangent1 = Vector2D.fromPoints(p1, p2);\n            const tangent2 = Vector2D.fromPoints(p4, p3);\n            let dmax = 0;\n\n            if (zeroVector.equals(tangent1) === false) {\n                const perpendicular = baseline.perpendicular(tangent1);\n\n                dmax = perpendicular.length();\n            }\n            if (zeroVector.equals(tangent2) === false) {\n                const perpendicular = baseline.perpendicular(tangent2);\n\n                dmax = Math.max(dmax, perpendicular.length());\n            }\n\n            if (dmax > flatness) {\n                tesselateInterior(p1, p5, p8, p10);\n                points.push(new Point2D(p10.x, p10.y));\n                tesselateInterior(p10, p9, p7, p4);\n            }\n            else {\n                points.push(new Point2D(p10.x, p10.y));\n            }\n        }\n\n        // add interior points\n        tesselateInterior(this.p1, this.p2, this.p3, this.p4);\n\n        // add last point\n        points.push(this.p4);\n\n        return new Polygon2D(points);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return (\n            \"M\" + this.p1.x + \",\" + this.p1.y + \" \" +\n            \"C\" + this.p2.x + \",\" + this.p2.y +\n            \" \" + this.p3.x + \",\" + this.p3.y +\n            \" \" + this.p4.x + \",\" + this.p4.y\n        );\n    }\n}\n\nexport default CubicBezier2D;\n","/* eslint-disable class-methods-use-this */\n/**\n *  Ellipse2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Ellipse2D\n */\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  Ellipse2D\n */\nclass Ellipse2D {\n    /**\n     *  @param {module:kld-affine.Point2D} center\n     *  @param {number} radiusX\n     *  @param {number} radiusY\n     *  @returns {module:kld-contours~Ellipse2D}\n     */\n    constructor(center, radiusX, radiusY) {\n        this.center = center;\n        this.radiusX = radiusX;\n        this.radiusY = radiusY;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        return new BoundingBox2D(\n            this.center.x - this.radiusX,\n            this.center.y - this.radiusY,\n            this.radiusX * 2.0,\n            this.radiusY * 2.0\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return new Polygon2D();\n    }\n}\n\nexport default Ellipse2D;\n","/**\n *  Line2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Line2D\n */\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  Line2D\n */\nclass Line2D {\n    /**\n     *  @param {module:kld-affine.Point2D} p1\n     *  @param {module:kld-affine.Point2D} p2\n     *  @returns {module:kld-contours~Line2D}\n     */\n    constructor(p1, p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        const min = this.p1.min(this.p2);\n        const max = this.p1.max(this.p2);\n\n        return new BoundingBox2D(\n            min.x,\n            min.y,\n            max.x - min.x,\n            max.y - min.y\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return new Polygon2D([this.p1, this.p2]);\n    }\n}\n\nexport default Line2D;\n","/**\n *  QuadraticBezier2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module QuadraticBezier2D\n */\nimport {Polynomial, SqrtPolynomial} from \"kld-polynomial\";\nimport {Matrix2D, Point2D, Vector2D} from \"kld-affine\";\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  QuadraticBezier2D\n */\nclass QuadraticBezier2D {\n    /**\n     *  @param {module:kld-affine.Point2D} p1\n     *  @param {module:kld-affine.Point2D} p2\n     *  @param {module:kld-affine.Point2D} p3\n     *  @returns {module:kld-contours~QuadraticBezier2D}\n     */\n    constructor(p1, p2, p3) {\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n    }\n\n    /**\n     *  getPointAtParameter\n     *\n     *  @param {number} t\n     *  @returns {module:kld-affine.Point2D}\n     */\n    getPointAtParameter(t) {\n        // TODO: validate t in [0,1]\n\n        // first round of lerps\n        const p4 = this.p1.lerp(this.p2, t);\n        const p5 = this.p2.lerp(this.p3, t);\n\n        return p4.lerp(p5, t);\n    }\n\n    /**\n     *  splitAtParameter\n     *\n     *  @param {number} t\n     *  @returns {Array<module:kld-contours~QuadraticBezier2D>}\n     */\n    splitAtParameter(t) {\n        // first round of lerps\n        const p4 = this.p1.lerp(this.p2, t);\n        const p5 = this.p2.lerp(this.p3, t);\n\n        // second round of lerps\n        const p6 = p4.lerp(p5, t);\n\n        return [\n            new QuadraticBezier2D(this.p1, p4, p6),\n            new QuadraticBezier2D(p6, p5, this.p3)\n        ];\n    }\n\n    /**\n     *  getBernsteinPolynomials\n     *\n     *  @returns {{x: module:kld-polynomial.Polynomial, y: module:kld-polynomial.Polynomial}}\n     */\n    getBernsteinPolynomials() {\n        let a; // temporary variables\n\n        a = this.p2.multiply(-2);\n        const c2 = this.p1.add(a.add(this.p3));\n\n        a = this.p1.multiply(-2);\n        const b = this.p2.multiply(2);\n        const c1 = a.add(b);\n\n        const c0 = this.p1;\n\n        return {\n            x: new Polynomial(c2.x, c1.x, c0.x),\n            y: new Polynomial(c2.y, c1.y, c0.y)\n        };\n    }\n\n    /**\n     *  getArcLengthPolynomial\n     *\n     *  @returns {module:kld-polynomial.SqrtPolynomial}\n     */\n    getArcLengthPolynomial() {\n        /* eslint-disable-next-line no-prototype-builtins */\n        if (!this.hasOwnProperty(\"arcLengthPolynomial\")) {\n            let a;\n\n            a = this.p2.multiply(-2);\n            const c2 = this.p1.add(a.add(this.p3));\n\n            a = this.p1.multiply(-2);\n            const b = this.p2.multiply(2);\n            const c1 = a.add(b);\n\n            //  ____________\n            //  dx^2 + dy^2\n            //\n            this.arcLengthPolynomial = new SqrtPolynomial(\n                4 * (c2.x * c2.x + c2.y * c2.y),\n                4 * (c1.x * c2.x + c1.y * c2.y),\n                c1.x * c1.x + c1.y * c1.y\n            );\n\n            // this.arcLength = this.arcLengthPolynomial.romberg(0, 1);\n            this.arcLength = this.arcLengthPolynomial.simpson(0, 1);\n        }\n\n        return this.arcLengthPolynomial;\n    }\n\n    /**\n     *  getParameterFromArcLength\n     *\n     *  @param {number} arcLength\n     *  @returns {number}\n     */\n    getParameterFromArcLength(arcLength) {\n        // TODO: extract common Bezier code\n\n        // make sure the arc length polynomial and arc length values have been calculated\n        const arcLengthPolynomial = this.getArcLengthPolynomial();\n        let result;\n\n        if (arcLength <= 0) {\n            result = 0;\n        }\n        else if (arcLength >= this.arcLength) {\n            result = 1;\n        }\n        else {\n            const TOLERANCE = 1e-9;\n            const MAXITERS = 20;\n\n            result = arcLength / this.arcLength;\n\n            for (let i = 0; i <= MAXITERS; i++) {\n                const diff = arcLengthPolynomial.romberg(0, result) - arcLength;\n\n                if (Math.abs(diff) < TOLERANCE) {\n                    break;\n                }\n\n                const value = arcLengthPolynomial.eval(result);\n\n                if (value === 0) {\n                    break;\n                }\n\n                result -= diff / value;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        const polys = this.getBernsteinPolynomials();\n        const dx = polys.x.getDerivative();\n        const dy = polys.y.getDerivative();\n        let roots = dx.getRootsInInterval(0, 1);\n        roots = roots.concat(dy.getRootsInInterval(0, 1));\n\n        let min = this.p1.min(this.p3);\n        let max = this.p1.max(this.p3);\n\n        roots.forEach(function(t) {\n            if (0 <= t && t <= 1) {\n                const testPoint = new Point2D(\n                    polys.x.eval(t),\n                    polys.y.eval(t)\n                );\n\n                min = min.min(testPoint);\n                max = max.max(testPoint);\n            }\n        });\n\n        return new BoundingBox2D(\n            min.x,\n            min.y,\n            max.x - min.x,\n            max.y - min.y\n        );\n    }\n\n    /**\n     *  getAlignedBoundingBox\n     *\n     *  @returns {{ bbox: module:kld-contours~BoundingBox2D, transform: module:kld-affine.Matrix2D }}\n     */\n    getAlignedBoundingBox() {\n        return {\n            bbox: this.getAlignedBezier().getBoundingBox(),\n            transform: Matrix2D\n                .translation(this.p1.x, this.p1.y)\n                .rotateFromVector(Vector2D.fromPoints(this.p1, this.p3))\n        };\n    }\n\n    /**\n     *  getAlignedBezier\n     *\n     *  @returns {module:kld-contours~QuadraticBezier2D}\n     */\n    getAlignedBezier() {\n        const matrix = Matrix2D\n            .translation(this.p1.x, this.p1.y) // move p1 to the origin\n            .rotateFromVector(Vector2D.fromPoints(this.p1, this.p3)) // rotate vector from p1 to p4 to x-axis\n            .inverse(); // reverse transforms\n\n        // apply to each point and create new Bezier\n        return new QuadraticBezier2D(\n            this.p1.transform(matrix),\n            this.p2.transform(matrix),\n            this.p3.transform(matrix)\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @param {number} [flatness]\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D(flatness) {\n        const points = [];\n        const zeroVector = new Vector2D(0, 0);\n\n        flatness = flatness !== undefined ? flatness : 1.0;\n\n        // add first point\n        points.push(this.p1);\n\n        // add middle points\n        /**\n         *  @param {number} p1\n         *  @param {number} p2\n         *  @param {number} p3\n         */\n        function tesselateInterior(p1, p2, p3) {\n            // round 1\n            const p4 = p1.lerp(p2, 0.5);\n            const p5 = p2.lerp(p3, 0.5);\n\n            // round 2\n            const p6 = p4.lerp(p5, 0.5);\n\n            const baseline = Vector2D.fromPoints(p1, p3);\n            const tangent = Vector2D.fromPoints(p1, p2);\n            let dmax = 0;\n\n            if (zeroVector.equals(tangent) === false) {\n                const perpendicular = baseline.perpendicular(tangent);\n\n                dmax = perpendicular.length();\n            }\n\n            if (dmax > flatness) {\n                tesselateInterior(p1, p4, p6);\n                points.push(new Point2D(p6.x, p6.y));\n                tesselateInterior(p6, p5, p3);\n            }\n            else {\n                points.push(new Point2D(p6.x, p6.y));\n            }\n        }\n\n        // add interior points\n        tesselateInterior(this.p1, this.p2, this.p3);\n\n        // add last point\n        points.push(this.p3);\n\n        return new Polygon2D(points);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return (\n            \"M\" + this.p1.x + \",\" + this.p1.y + \" \" +\n            \"Q\" + this.p2.x + \",\" + this.p2.y +\n            \" \" + this.p3.x + \",\" + this.p3.y\n        );\n    }\n}\n\nexport default QuadraticBezier2D;\n","/**\n *  Rectangle2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Rectangle2D\n */\nimport {Point2D} from \"kld-affine\";\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  Rectangle2D\n */\nclass Rectangle2D {\n    /**\n     *  @param {number} x\n     *  @param {number} y\n     *  @param {number} width\n     *  @param {number} height\n     *  @returns {module:kld-contours~Rectangle2D}\n     */\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        return new BoundingBox2D(\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return new Polygon2D([\n            new Point2D(this.x, this.y),\n            new Point2D(this.x + this.width, this.y),\n            new Point2D(this.x + this.width, this.y + this.height),\n            new Point2D(this.x, this.y + this.height)\n        ]);\n    }\n}\n\nexport default Rectangle2D;\n"],"names":["BoundingBox2D","x","y","width","height","that","this","Polygon2D","points","undefined","length","min","max","i","point","map","p","join","Circle2D","center","radius","sign","NaN","Polynomial","coefs","arguments","push","_variable","_s","poly","slice","isNaN","Error","result","d1","getDegree","d2","dmax","Math","v1","v2","j","scalar","TOLERANCE","abs","pop","minValue","eval","maxValue","tmp1","log","tmp2","LN10","ACCURACY","iters","ceil","LN2","value","signs","round","signString","n","range","iter","delta","sum","st","t","s","os","ost","Array","MAX","h","dy","trapezoid","interpolate","derivative","simplify","getLinearRoot","getQuadraticRoots","getCubicRoots","getQuarticRoots","roots","bisection","droots","getDerivative","getRootsInInterval","a","results","b","d","e","sqrt","c3","c2","c1","offset","discrim","halfB","ZEROepsilon","zeroErrorEstimate","root","tmp","pow","distance","angle","atan2","cos","sin","sqrt3","divide_scalar","poly_d","derrt","getRoots","sort","dery","nr","rb","bounds","maxabsX","minX","maxX","dx","guesses","minmax","f","df","newton_secant_bisection","concat","an","reduce","m","v","nm","coefSelectionFunc","find2Max","acc","bi","nearmax","max_nearmax_pos","negX","posX","reverse","res","bounds_UpperReal_Fujiwara","urb","bounds_LowerReal_Fujiwara","c","err","pv","cv","prev","curr","p1","undersqrt","p2","accum","ai","prev_a","pos","neg","maxRealPos","maxRealNeg","minComplex","xs","ys","constructor","ns","diff","dift","ho","hp","w","den","x0","max_iterations","dfx","x_correction","x_new","y_atmin","y_atmax","prev_dfx","prev_x_ef_correction","min_correction_factor","isBounded","isEnoughCorrection","SqrtPolynomial","Point2D","precision","omt","matrix","Vector2D","divide","dot","radians","acos","cross","subtract","project","percent","multiply","Matrix2D","isIdentity","det1","idet","det2","det3","tx","ty","scale","scaleX","scaleY","cx","cy","vector","unit","tan","E","F","G","H","Q","R","a1","a2","theta","phi","translation","rotation","nonUniformScaling","rotation0","IDENTITY","CubicBezier2D","p3","p4","p5","lerp","p6","p7","p8","p9","p10","add","c0","hasOwnProperty","arcLengthPolynomial","arcLength","romberg","getArcLengthPolynomial","polys","getBernsteinPolynomials","forEach","testPoint","bbox","getAlignedBezier","getBoundingBox","transform","rotateFromVector","fromPoints","inverse","flatness","zeroVector","tesselateInterior","baseline","tangent1","tangent2","equals","perpendicular","Ellipse2D","radiusX","radiusY","Line2D","QuadraticBezier2D","simpson","tangent","Rectangle2D"],"mappings":"ugCAUMA,wBAQUC,EAAGC,EAAGC,EAAOC,kBAChBH,EAAIA,OACJC,EAAIA,OACJC,MAAQA,OACRC,OAASA,6CASTC,UAEDC,KAAKL,EAAKI,EAAKJ,EAAII,EAAKF,OAAWG,KAAKL,EAAIK,KAAKH,MAASE,EAAKJ,GAC/DK,KAAKJ,EAAKG,EAAKH,EAAIG,EAAKD,QAAYE,KAAKJ,EAAII,KAAKF,OAAUC,EAAKH,2CAU/C,IAAfI,KAAKH,OAA+B,IAAhBG,KAAKF,gDAU5B,QACAE,KAAKL,EAAI,IACTK,KAAKJ,EAAI,IACTI,KAAKH,MAAQ,IACbG,KAAKF,OAAS,aC/CpBG,wBAKUC,kBACHA,YAAqBC,IAAXD,EAAwBA,EAAS,yDAS5CF,KAAKE,OAAOE,OAAS,EAAG,SACpBC,EAAML,KAAKE,OAAO,GAClBI,EAAMN,KAAKE,OAAO,GAEbK,EAAI,EAAGA,EAAIP,KAAKE,OAAOE,OAAQG,IAAK,KACnCC,EAAQR,KAAKE,OAAOK,GAE1BF,EAAMA,EAAIA,IAAIG,GACdF,EAAMA,EAAIA,IAAIE,UAGX,IAAId,EACPW,EAAIV,EACJU,EAAIT,EACJU,EAAIX,EAAIU,EAAIV,EACZW,EAAIV,EAAIU,EAAIV,UAIb,IAAIF,EAAc,EAAG,EAAG,EAAG,gDAS3BM,+CASAA,KAAKE,OAAOO,IAAI,SAAAC,mBACTA,EAAEf,eAAMe,EAAEd,KACrBe,KAAK,cCpDVC,wBAMUC,EAAQC,kBACXD,OAASA,OACTC,OAASA,4DASP,IAAIpB,EACPM,KAAKa,OAAOlB,EAAIK,KAAKc,OACrBd,KAAKa,OAAOjB,EAAII,KAAKc,OACP,EAAdd,KAAKc,OACS,EAAdd,KAAKc,qDAUF,IAAIb,WC1BnB,SAASc,EAAKpB,SAEU,iBAANA,EAAiBA,EAAIA,EAAI,GAAK,EAAI,EAAIA,GAAMA,EAAIA,EAAIqB,IAAMA,QAStEC,yCAQOC,MAAQ,OAER,IAAIX,EAAIY,UAAMf,OAAS,EAAGG,GAAK,EAAGA,SAC9BW,MAAME,KAAWb,uBAAAA,mBAAAA,SAGrBc,UAAY,SACZC,GAAK,gDAkMJC,EAAO,IAAIN,SAEjBM,EAAKL,MAAQlB,KAAKkB,MAAMM,QAEjBD,+BAQN5B,MACG8B,MAAM9B,SACA,IAAI+B,kEAA2D/B,gBAGrEgC,EAAS,EAEJpB,EAAIP,KAAKkB,MAAMd,OAAS,EAAGG,GAAK,EAAGA,IACxCoB,EAASA,EAAShC,EAAIK,KAAKkB,MAAMX,UAG9BoB,8BASP5B,WACM4B,EAAS,IAAIV,EACbW,EAAK5B,KAAK6B,YACVC,EAAK/B,EAAK8B,YACVE,EAAOC,KAAK1B,IAAIsB,EAAIE,GAEjBvB,EAAI,EAAGA,GAAKwB,EAAMxB,IAAK,KACtB0B,EAAM1B,GAAKqB,EAAM5B,KAAKkB,MAAMX,GAAK,EACjC2B,EAAM3B,GAAKuB,EAAM/B,EAAKmB,MAAMX,GAAK,EAEvCoB,EAAOT,MAAMX,GAAK0B,EAAKC,SAGpBP,mCASF5B,WACC4B,EAAS,IAAIV,EAEVV,EAAI,EAAGA,GAAKP,KAAK6B,YAAc9B,EAAK8B,YAAatB,IACtDoB,EAAOT,MAAME,KAAK,OAGjB,IAAIb,EAAI,EAAGA,GAAKP,KAAK6B,YAAatB,QAC9B,IAAI4B,EAAI,EAAGA,GAAKpC,EAAK8B,YAAaM,IACnCR,EAAOT,MAAMX,EAAI4B,IAAMnC,KAAKkB,MAAMX,GAAKR,EAAKmB,MAAMiB,UAInDR,wCAQGS,OACL,IAAI7B,EAAI,EAAGA,EAAIP,KAAKkB,MAAMd,OAAQG,SAC9BW,MAAMX,IAAM6B,mCAShBC,QACalC,IAAdkC,IACAA,EAAY,WAGX,IAAI9B,EAAIP,KAAK6B,YAAatB,GAAK,GAC5ByB,KAAKM,IAAItC,KAAKkB,MAAMX,KAAO8B,EADI9B,SAE1BW,MAAMqB,wCAgBblC,EAAKC,OAGPqB,EAFAa,EAAWxC,KAAKyC,KAAKpC,GACrBqC,EAAW1C,KAAKyC,KAAKnC,MAGrB0B,KAAKM,IAAIE,IAAavB,EAAWoB,UACjCV,EAAStB,OAER,GAAI2B,KAAKM,IAAII,IAAazB,EAAWoB,UACtCV,EAASrB,OAER,GAAIkC,EAAWE,GAAY,UACtBC,EAAOX,KAAKY,IAAItC,EAAMD,GACtBwC,EAAOb,KAAKc,KAAO7B,EAAW8B,SAC9BC,EAAQhB,KAAKiB,MAAMN,EAAOE,GAAQb,KAAKkB,KAEpC3C,EAAI,EAAGA,EAAIyC,EAAOzC,IAAK,CAC5BoB,EAAS,IAAOtB,EAAMC,OAChB6C,EAAQnD,KAAKyC,KAAKd,MAEpBK,KAAKM,IAAIa,IAAUlC,EAAWoB,gBAI9Bc,EAAQX,EAAW,GACnBlC,EAAMqB,EACNe,EAAWS,IAGX9C,EAAMsB,EACNa,EAAWW,UAKhBxB,6CASDT,EAAQ,GACRkC,EAAQ,GAEL7C,EAAIP,KAAKkB,MAAMd,OAAS,EAAGG,GAAK,EAAGA,IAAK,KACzC4C,EAAQnB,KAAKqB,MAAsB,IAAhBrD,KAAKkB,MAAMX,IAAa,OAEjC,IAAV4C,EAAa,KACPG,EAAcH,EAAQ,EAAK,MAAQ,MAEzCA,EAAQnB,KAAKM,IAAIa,GAEb5C,EAAI,IACU,IAAV4C,EACAA,EAAQnD,KAAKqB,UAGb8B,GAASnD,KAAKqB,WAIlBd,EAAI,IACJ4C,GAAS,IAAM5C,GAGnB6C,EAAMhC,KAAKkC,GACXpC,EAAME,KAAK+B,IAInBC,EAAM,GAAmB,QAAbA,EAAM,GAAgB,GAAK,YAEnCzB,EAAS,GAEJpB,EAAI,EAAGA,EAAIW,EAAMd,OAAQG,IAC9BoB,GAAUyB,EAAM7C,GAAKW,EAAMX,UAGxBoB,oCAaDtB,EAAKC,EAAKiD,MACZ9B,MAAMpB,IAAQoB,MAAMnB,IAAQmB,MAAM8B,SAC5B,IAAI7B,MAAM,wDAGd8B,EAAQlD,EAAMD,KAEV,IAANkD,EAAS,KACHf,EAAWxC,KAAKyC,KAAKpC,GACrBqC,EAAW1C,KAAKyC,KAAKnC,QAEtBgB,GAAK,GAAMkC,GAAShB,EAAWE,OAEnC,SACKe,EAAO,GAAMF,EAAI,EACjBG,EAAQF,EAAQC,EAClB9D,EAAIU,EAAM,GAAMqD,EAChBC,EAAM,EAEDpD,EAAI,EAAGA,EAAIkD,EAAMlD,IACtBoD,GAAO3D,KAAKyC,KAAK9C,GACjBA,GAAK+D,OAGJpC,GAAK,IAAOtB,KAAKsB,GAAKkC,EAAQG,EAAMF,MAGzChC,MAAMzB,KAAKsB,UACL,IAAII,MAAM,+CAGb1B,KAAKsB,mCAYRjB,EAAKC,MACLmB,MAAMpB,IAAQoB,MAAMnB,SACd,IAAIoB,MAAM,0DAGd8B,EAAQlD,EAAMD,EAChBuD,EAAK,GAAMJ,GAASxD,KAAKyC,KAAKpC,GAAOL,KAAKyC,KAAKnC,IAC/CuD,EAAID,EACJE,EAAI,EAAMF,EAAK,EACfG,EAAKD,EACLE,EAAMJ,EAGNH,EAAO,EAEFF,EAAI,EAAGA,GAAK,GAAIA,IAAK,SACpBG,EAAQF,EAAQC,EAClB9D,EAAIU,EAAM,GAAMqD,EAChBC,EAAM,EAEDpD,EAAI,EAAGA,GAAKkD,EAAMlD,IACvBoD,GAAO3D,KAAKyC,KAAK9C,GACjBA,GAAK+D,KAKTI,GAAK,GADLF,EADAC,EAAI,IAAOA,EAAIL,EAAQG,EAAMF,IAEbO,GAAO,EAEnBhC,KAAKM,IAAIwB,EAAIC,GAlBH,KAkBqB/B,KAAKM,IAAIyB,SAI5CA,EAAKD,EACLE,EAAMJ,EACNH,IAAS,SAGNK,kCAUHzD,EAAKC,MACLmB,MAAMpB,IAAQoB,MAAMnB,SACd,IAAIoB,MAAM,sDAMdoC,EAAI,IAAIG,MAAMC,IACdC,EAAI,IAAIF,MAAMC,IAChBvC,EAAS,CAAC/B,EAAG,EAAGwE,GAAI,GAExBD,EAAE,GAAK,MAEF,IAAIhC,EAAI,EAAGA,GATJ,KAUR2B,EAAE3B,EAAI,GAAKnC,KAAKqE,UAAUhE,EAAKC,EAAK6B,KAEhCA,GAXE,IAYFR,EAASV,EAAWqD,YAAYH,EAAGL,EAZjC,EAYuC3B,EAZvC,EAY8C,GAC5CH,KAAKM,IAAIX,EAAOyC,KAZV,KAY6BzC,EAAO/B,KAL5BuC,IAUtB2B,EAAE3B,GAAK2B,EAAE3B,EAAI,GACbgC,EAAEhC,GAAK,IAAOgC,EAAEhC,EAAI,UAGjBR,EAAO/B,6CAWPI,KAAKkB,MAAMd,OAAS,kDASrBmE,EAAa,IAAItD,EAEdV,EAAI,EAAGA,EAAIP,KAAKkB,MAAMd,OAAQG,IACnCgE,EAAWrD,MAAME,KAAKb,EAAIP,KAAKkB,MAAMX,WAGlCgE,yCASH5C,cAEC6C,WAEGxE,KAAK6B,kBACJ,EAAGF,EAAS,cACZ,EAAGA,EAAS3B,KAAKyE,2BACjB,EAAG9C,EAAS3B,KAAK0E,+BACjB,EAAG/C,EAAS3B,KAAK2E,2BACjB,EAAGhD,EAAS3B,KAAK4E,gCAElBjD,EAAS,UAGVA,6CAUQtB,EAAKC,OACduE,EAAQ,YAKLzD,EAAK+B,GACW,iBAAVA,GACP0B,EAAMzD,KAAK+B,MAIM,IAArBnD,KAAK6B,kBACC,IAAIH,MAAM,8DAEf,GAAyB,IAArB1B,KAAK6B,YACVT,EAAKpB,KAAK8E,UAAUzE,EAAKC,QAExB,KAGKyE,EADQ/E,KAAKgF,gBACEC,mBAAmB5E,EAAKC,MAEzCyE,EAAO3E,OAAS,EAAG,CAEnBgB,EAAKpB,KAAK8E,UAAUzE,EAAK0E,EAAO,SAG3B,IAAIxE,EAAI,EAAGA,GAAKwE,EAAO3E,OAAS,EAAGG,IACpCa,EAAKpB,KAAK8E,UAAUC,EAAOxE,GAAIwE,EAAOxE,EAAI,KAI9Ca,EAAKpB,KAAK8E,UAAUC,EAAOA,EAAO3E,OAAS,GAAIE,SAI/Cc,EAAKpB,KAAK8E,UAAUzE,EAAKC,WAI1BuE,8CASDlD,EAAS,GACTuD,EAAIlF,KAAKkB,MAAM,UAEX,IAANgE,GACAvD,EAAOP,MAAMpB,KAAKkB,MAAM,GAAKgE,GAG1BvD,kDASDwD,EAAU,MAES,IAArBnF,KAAK6B,YAAmB,KAClBqD,EAAIlF,KAAKkB,MAAM,GACfkE,EAAIpF,KAAKkB,MAAM,GAAKgE,EAEpBG,EAAID,EAAIA,EAAI,GADRpF,KAAKkB,MAAM,GAAKgE,MAGtBG,EAAI,EAAG,KACDC,EAAItD,KAAKuD,KAAKF,GAEpBF,EAAQ/D,KAAK,KAAQgE,EAAIE,IACzBH,EAAQ/D,KAAK,KAAQgE,EAAIE,SAEd,IAAND,GAELF,EAAQ/D,KAAK,IAAOgE,UAIrBD,8CAaDA,EAAU,MAES,IAArBnF,KAAK6B,YAAmB,KAClB2D,EAAKxF,KAAKkB,MAAM,GAChBuE,EAAKzF,KAAKkB,MAAM,GAAKsE,EACrBE,EAAK1F,KAAKkB,MAAM,GAAKsE,EAGrBN,GAAK,EAAIQ,EAAKD,EAAKA,GAAM,EACzBL,GAAK,EAAIK,EAAKA,EAAKA,EAAK,EAAIC,EAAKD,EAAK,IAHjCzF,KAAKkB,MAAM,GAAKsE,IAG4B,GACjDG,EAASF,EAAK,EAChBG,EAAUR,EAAIA,EAAI,EAAIF,EAAIA,EAAIA,EAAI,GAChCW,EAAQT,EAAI,EAEZU,EAAc9F,KAAK+F,uBAErB/D,KAAKM,IAAIsD,IAAYE,IACrBF,EAAU,GAGVA,EAAU,EAAG,KAETI,EADEV,EAAItD,KAAKuD,KAAKK,GAGhBK,GAAOJ,EAAQP,EAGfU,EADAC,GAAO,EACAjE,KAAKkE,IAAID,EAAK,EAAI,IAGjBjE,KAAKkE,KAAKD,EAAK,EAAI,IAG/BA,GAAOJ,EAAQP,IAEJ,EACPU,GAAQhE,KAAKkE,IAAID,EAAK,EAAI,GAG1BD,GAAQhE,KAAKkE,KAAKD,EAAK,EAAI,GAG/Bd,EAAQ/D,KAAK4E,EAAOL,QAEnB,GAAIC,EAAU,EAAG,KACZO,EAAWnE,KAAKuD,MAAML,EAAI,GAC1BkB,EAAQpE,KAAKqE,MAAMrE,KAAKuD,MAAMK,IAAWC,GAAS,EAClDS,EAAMtE,KAAKsE,IAAIF,GACfG,EAAMvE,KAAKuE,IAAIH,GACfI,EAAQxE,KAAKuD,KAAK,GAExBJ,EAAQ/D,KAAK,EAAI+E,EAAWG,EAAMX,GAClCR,EAAQ/D,MAAM+E,GAAYG,EAAME,EAAQD,GAAOZ,GAC/CR,EAAQ/D,MAAM+E,GAAYG,EAAME,EAAQD,GAAOZ,OAE9C,KACGM,EAGAA,EADAJ,GAAS,GACF7D,KAAKkE,IAAIL,EAAO,EAAI,GAGrB7D,KAAKkE,KAAKL,EAAO,EAAI,GAG/BV,EAAQ/D,KAAK,EAAI6E,EAAMN,GAEvBR,EAAQ/D,MAAM6E,EAAMN,WAIrBR,gDAYHA,EAAU,GACR5B,EAAIvD,KAAK6B,eAEL,IAAN0B,EAAS,KACHhC,EAAO,IAAIN,EAEjBM,EAAKL,MAAQlB,KAAKkB,MAAMM,QACxBD,EAAKkF,cAAclF,EAAKL,MAAMqC,IAI1BvB,KAAKM,IAAIf,EAAKL,MAAM,IAAM,GAFjB,MAE6Bc,KAAKM,IAAIf,EAAKL,MAAM,MAC1DK,EAAKL,MAAM,GAAK,WAGdwF,EAASnF,EAAKyD,gBACd2B,EAAQD,EAAOE,WAAWC,KAAK,SAAC3B,EAAGE,UAAMF,EAAIE,IAC7C0B,EAAO,GACPC,EAAKJ,EAAMvG,OAAS,EACpB4G,EAAKhH,KAAKiH,SAEVC,EAAUlF,KAAK1B,IAAI0B,KAAKM,IAAI0E,EAAGG,MAAOnF,KAAKM,IAAI0E,EAAGI,OAClDtB,EAAc9F,KAAK+F,kBAAkBmB,GAElC3G,EAAI,EAAGA,GAAKwG,EAAIxG,IACrBuG,EAAK1F,KAAKG,EAAKkB,KAAKkE,EAAMpG,SAGzB,IAAIA,EAAI,EAAGA,GAAKwG,EAAIxG,IACjByB,KAAKM,IAAIwE,EAAKvG,IAAMuF,IACpBgB,EAAKvG,GAAK,OAIdA,EAAI,EACF8G,EAAKrF,KAAK1B,IAAI,IAAO0G,EAAGI,KAAOJ,EAAGG,MAAQ5D,EA1BnC,OA2BP+D,EAAU,GACVC,EAAS,MAEXR,GAAM,EAAG,KACO,IAAZD,EAAK,GACD/F,EAAK+F,EAAK,MAAQ/F,EAAKQ,EAAKkB,KAAKkE,EAAM,GAAKU,GAAMP,EAAK,MACvDQ,EAAQlG,KAAKuF,EAAM,GAAKU,GACxBE,EAAOnG,KAAK,CAAC4F,EAAGG,KAAMR,EAAM,OAIhCxB,EAAQ/D,KAAKuF,EAAM,GAAIA,EAAM,IAC7BpG,KAGGA,EAAIwG,EAAIxG,IACS,IAAhBuG,EAAKvG,EAAI,IACT4E,EAAQ/D,KAAKuF,EAAMpG,EAAI,GAAIoG,EAAMpG,EAAI,IACrCA,KAEKQ,EAAK+F,EAAKvG,MAAQQ,EAAK+F,EAAKvG,EAAI,MACrC+G,EAAQlG,MAAMuF,EAAMpG,GAAKoG,EAAMpG,EAAI,IAAM,GACzCgH,EAAOnG,KAAK,CAACuF,EAAMpG,GAAIoG,EAAMpG,EAAI,MAGxB,IAAbuG,EAAKC,IAAahG,EAAK+F,EAAKC,MAAShG,EAAKQ,EAAKkB,KAAKkE,EAAMI,GAAMM,GAAMP,EAAKC,MAC3EO,EAAQlG,KAAKuF,EAAMI,GAAMM,GACzBE,EAAOnG,KAAK,CAACuF,EAAMI,GAAKC,EAAGI,YAQ7BI,EAAI,SAAS7H,UACR4B,EAAKkB,KAAK9C,IAOf8H,EAAK,SAAS9H,UACT+G,EAAOjE,KAAK9C,OAGnB2H,EAAQlH,OAAS,MACZG,EAAI,EAAGA,EAAI+G,EAAQlH,OAAQG,IAC5B+G,EAAQ/G,GAAKU,EAAWyG,wBAAwBJ,EAAQ/G,GAAIiH,EAAGC,EAAI,GAAIF,EAAOhH,GAAG,GAAIgH,EAAOhH,GAAG,IAIvG4E,EAAUA,EAAQwC,OAAOL,UAGtBnC,4CASO+B,WAIS,IAAZA,EAAyB,KAC1BF,EAJGhH,KAIOiH,SAEhBC,EAAUlF,KAAK1B,IAAI0B,KAAKM,IAAI0E,EAAGG,MAAOnF,KAAKM,IAAI0E,EAAGI,UAGlDF,EAAU,YACH,EAAIlF,KAAKM,IAVPtC,KAUgByC,KAThB,YAYPc,EAbOvD,KAaEkB,MAAMd,OAAS,EACxBwH,EAdO5H,KAcGkB,MAAMqC,UAEf,GAfM,MADAvD,KAgBWkB,MAAM2G,OAAO,SAACC,EAAGC,EAAGxH,OAClCyH,EAAKD,EAAIH,EAAK5F,KAAKkE,IAAIgB,EAAS3G,UAC/ByH,EAAKF,EAAIE,EAAKF,GACtB,2DAWC5C,EAAIlF,KAAKkB,MACPqC,EAAI2B,EAAE9E,OAAS,EACfwH,EAAK1C,EAAE3B,GAEF,IAAPqE,IACA1C,EAAIlF,KAAKkB,MAAMT,IAAI,SAAAsH,UAAKA,EAAIH,SAS5BK,EANE7C,EAAIF,EAAEzE,IAAI,SAACsH,EAAGxH,UACRA,EAAIgD,EACNvB,KAAKkE,IAAIlE,KAAKM,IAAW,IAAN/B,EAAWwH,EAAI,EAAIA,GAAI,GAAKxE,EAAIhD,IACnDwH,IAIJG,EAAW,SAASC,EAAKC,EAAI7H,UAC3B0H,EAAkB1H,KACd4H,EAAI7H,IAAM8H,GACVD,EAAIE,QAAUF,EAAI7H,IAClB6H,EAAI7H,IAAM8H,GAELD,EAAIE,QAAUD,IACnBD,EAAIE,QAAUD,IAGfD,GAGXF,EAAoB,SAAS1H,UAClBA,EAAIgD,GAAK2B,EAAE3E,GAAK,OAIrB+H,EAAkBlD,EAAEyC,OAAOK,EAAU,CAAC5H,IAAK,EAAG+H,QAAS,WAE7DJ,EAAoB,SAAS1H,UAClBA,EAAIgD,IAAOA,EAAI,GAAMhD,EAAI,EAAK2E,EAAE3E,GAAK,EAAI2E,EAAE3E,GAAK,IAMpD,CACHgI,MAAO,EAHanD,EAAEyC,OAAOK,EAAU,CAAC5H,IAAK,EAAG+H,QAAS,IAG9B/H,IAC3BkI,KAAM,EAAIF,EAAgBhI,6DAYxBiB,EAAO,IAAIN,EAEjBM,EAAKL,MAAQlB,KAAKkB,MAAMM,QAAQiH,cAE1BC,EAAMnH,EAAKoH,mCAEjBD,EAAIH,KAAO,EAAIG,EAAIH,KACnBG,EAAIF,KAAO,EAAIE,EAAIF,KAEZE,uCAWDE,EAAM5I,KAAK2I,4BACX3B,EAAK,CAACG,KAAMyB,EAAIL,KAAMnB,KAAMwB,EAAIJ,aAErB,IAAbI,EAAIL,MAA2B,IAAbK,EAAIJ,KACfxB,GAGM,IAAb4B,EAAIL,KACJvB,EAAGG,KAAOnH,KAAK6I,4BAA4BL,KAEzB,IAAbI,EAAIJ,OACTxB,EAAGI,KAAOpH,KAAK6I,4BAA4BN,MAG3CvB,EAAGG,KAAOH,EAAGI,OACbJ,EAAGG,KAAOH,EAAGI,KAAO,GAGjBJ,2DAYD8B,EAAI9I,KAAKkB,MAET6H,EAAM,GADC,MACW/G,KAAKM,IACzBwG,EAAEjB,OAAO,SAACmB,EAAIC,UACHjH,KAAKM,IAAI2G,GAAMjH,KAAKM,IAAI0G,GAAMC,EAAKD,KAIzCzI,EAAI,EAAGA,EAAIuI,EAAE1I,OAAS,EAAGG,IAC1ByB,KAAKM,IAAIwG,EAAEvI,IAAMwI,IACjBD,EAAEvI,GAAK,UAIRP,kDAUD8I,EAAI9I,KAAKkB,aAES,IAApB4H,EAAEA,EAAE1I,OAAS,SACRqG,cAAcqC,EAAEA,EAAE1I,OAAS,IAG7BJ,yDAWDkF,EAAIlF,KAAKkB,MACTqC,EAAI2B,EAAE9E,OAAS,SASd,EARK8E,EAAE2C,OAAO,SAACqB,EAAMC,EAAM5I,UAC1BA,IAAMgD,GAEE2F,GADRC,EAAOnH,KAAKM,IAAI6G,IACOA,EAEpBD,GACR,GAEclH,KAAKM,IAAI4C,EAAE3B,wDAWtB2B,EAAIlF,KAAKkB,MACTZ,EAAM4E,EAAE2C,OAAO,SAACqB,EAAMC,EAAM5I,UACpB,IAANA,GAEQ2I,GADRC,EAAOnH,KAAKM,IAAI6G,IACOA,EAEpBD,GACR,UAEIlH,KAAKM,IAAI4C,EAAE,KAAOlD,KAAKM,IAAI4C,EAAE,IAAM5E,sDAYpC4E,EAAIlF,KAAKkB,MACTqC,EAAI2B,EAAE9E,OAAS,EACfgJ,GAAMlE,EAAE3B,EAAI,IAAMA,EAAI2B,EAAE3B,IACxB8F,EAAYnE,EAAE3B,EAAI,GAAK2B,EAAE3B,EAAI,GAAK,EAAIA,GAAKA,EAAI,GAAK2B,EAAE3B,GAAK2B,EAAE3B,EAAI,GACnE+F,GAAM/F,EAAI,IAAMA,EAAI2B,EAAE3B,IAAMvB,KAAKuD,KAAK8D,UAEtCC,EAAK,IACLA,GAAMA,GAGH,CACHnC,KAAMiC,EAAKE,EACXlC,KAAMgC,EAAKE,sDAYTpE,EAAIlF,KAAKkB,MACTqC,EAAI2B,EAAE9E,OAAS,EACfmJ,EAAQrE,EAAE2C,OAAO,SAACM,EAAKqB,EAAIjJ,UACV,IAAf4H,EAAIsB,QAAuB,IAAPD,IACfrB,EAAIsB,OAAS,GAAQD,EAAK,GAC3BrB,EAAIuB,MAEFnJ,EAAI,GAAM,GAAQ4H,EAAIsB,OAAS,IAAUlJ,EAAI,GAAM,GAAQiJ,EAAK,IAClErB,EAAIwB,OAGZxB,EAAIsB,OAASD,EACNrB,GACR,CAACuB,IAAK,EAAGC,IAAK,EAAGF,OAAQ,UAErB,CACHG,WAAYL,EAAMG,IAClBG,WAAYN,EAAMI,IAClBG,WAAYvG,GAAKgG,EAAMG,IAAMH,EAAMI,4CAhlCxBI,EAAIC,EAAIzG,EAAGoC,EAAQhG,MAC9BoK,EAAGE,cAAgBhG,OAAS+F,EAAGC,cAAgBhG,YACzC,IAAIvC,MAAM,uDAEhBD,MAAM8B,IAAM9B,MAAMkE,IAAWlE,MAAM9B,SAC7B,IAAI+B,MAAM,gEAGhBnB,EACAX,EAAI,EACJwE,EAAK,EACH0E,EAAI,IAAI7E,MAAMV,GACd8B,EAAI,IAAIpB,MAAMV,GAChB2G,EAAK,EAELC,EAAOnI,KAAKM,IAAI3C,EAAIoK,EAAGpE,QAEtBpF,EAAI,EAAGA,EAAIgD,EAAGhD,IAAK,KACd6J,EAAOpI,KAAKM,IAAI3C,EAAIoK,EAAGpE,EAASpF,IAElC6J,EAAOD,IACPD,EAAK3J,EACL4J,EAAOC,GAEXtB,EAAEvI,GAAK8E,EAAE9E,GAAKyJ,EAAGrE,EAASpF,GAG9BX,EAAIoK,EAAGrE,EAASuE,GAChBA,QAEK,IAAIpC,EAAI,EAAGA,EAAIvE,EAAGuE,IAAK,KACnBvH,EAAI,EAAGA,EAAIgD,EAAIuE,EAAGvH,IAAK,KAClB8J,EAAKN,EAAGpE,EAASpF,GAAKZ,EACtB2K,EAAKP,EAAGpE,EAASpF,EAAIuH,GAAKnI,EAC1B4K,EAAIzB,EAAEvI,EAAI,GAAK8E,EAAE9E,GACnBiK,EAAMH,EAAKC,KAEH,IAARE,QACM,IAAI9I,MAAM,0FAGpB8I,EAAMD,EAAIC,EACVnF,EAAE9E,GAAK+J,EAAKE,EACZ1B,EAAEvI,GAAK8J,EAAKG,EAIhB5K,GADAwE,EAAM,GAAK8F,EAAK,GAAM3G,EAAIuE,EAAMgB,EAAEoB,EAAK,GAAK7E,EAAE6E,WAI3C,CAACtK,EAAAA,EAAGwE,GAAAA,mDAmBgBqG,EAAIjD,EAAGC,EAAIiD,EAAgBrK,EAAKC,OACvDX,EAAiBgL,EAA+BC,EAAcC,EAC9DjL,EAAGkL,EAASC,EADTC,EAAW,EAAQC,EAAuB,EAGjDtL,EAAI8K,MAGES,EAAwBlJ,KAAKkE,IAAI,IADtB,IAEXiF,EAA4B,iBAAR9K,GAAmC,iBAARC,KAEjD6K,EAAW,IACP9K,EAAMC,QACA,IAAIoB,MAAM,wDAGpBoJ,EAAUtD,EAAEnH,GACZ0K,EAAUvD,EAAElH,GAERS,EAAK+J,KAAa/J,EAAKgK,SACjB,IAAIrJ,MAAM,4EAIlB0J,EAAqB,kBAEfpJ,KAAKM,IAAIsI,IAAiBM,EAAwBlJ,KAAKM,IAAI3C,IAC9DsL,IAA0BtL,EAAIiL,EAAgBjL,GAI9CY,EAAI,EAAGA,EAAImK,EAAgBnK,IAAK,IAGzB,KAFZoK,EAAMlD,EAAG9H,IAEM,IACM,IAAbqL,QAEM,IAAItJ,MAAM,sCAIhBiJ,EAAMK,KAMdA,EAAWL,EACX/K,EAAI4H,EAAE7H,GAENkL,EAAQlL,GADRiL,EAAehL,EAAI+K,GAGfS,aAIAD,EAAW,IACPpK,EAAKnB,KAAOmB,EAAKgK,GACjBzK,EAAMX,EACNoL,EAAUnL,MAET,CAAA,GAAImB,EAAKnB,KAAOmB,EAAK+J,GAIrB,CACDnL,EAAIkL,QAJJxK,EAAMV,EACNmL,EAAUlL,KAOTiL,EAAQxK,GAASwK,EAAQvK,EAAM,IAC5BS,EAAK+J,KAAa/J,EAAKgK,aAMrB3G,EAAK2G,EAAUD,EACfzD,EAAK/G,EAAMD,KAGbuK,EADO,IAAPxG,EACezE,GAAKU,EAAW,GAALgH,GAErBrF,KAAKM,IAAI8B,EAAKpC,KAAK3B,IAAIyK,EAASC,IARrB,GASDpL,GAAKU,EAAMgH,GAAM,IAAOrF,KAAKM,IAAIwI,GAAW9I,KAAKM,IAAIyI,IAR5C,IAAA,OAWTpL,GAAKU,EAAMyK,EAAU1G,EAAKiD,GAE7CwD,EAAQlL,EAAIiL,EAERQ,WAMZH,EAAuBtL,EAAIkL,EAC3BlL,EAAIkL,SAGDlL,WA46BfsB,EAAWoB,UAAY,KACvBpB,EAAW8B,SAAW,OCnoChBsI,2TAAuBpK,mCAOpBtB,OAGGgC,0CAAoBhC,MAKpBqC,KAAKM,IAAIX,GAPK,OAQdA,EAAS,GAGTA,EAAS,QACH,IAAID,MAAM,0EAGbM,KAAKuD,KAAK5D,4CAWV,qDAAmB,aCtC5B2J,wBAQU3L,EAAGC,kBACND,OAAUQ,IAANR,EAAkBA,EAAI,OAC1BC,OAAUO,IAANP,EAAkBA,EAAI,mDASxB,IAAII,KAAKiK,YAAYjK,KAAKL,EAAGK,KAAKJ,+BASzCG,UACO,IAAIC,KAAKiK,YAAYjK,KAAKL,EAAII,EAAKJ,EAAGK,KAAKJ,EAAIG,EAAKH,oCAStDG,UACE,IAAIC,KAAKiK,YAAYjK,KAAKL,EAAII,EAAKJ,EAAGK,KAAKJ,EAAIG,EAAKH,oCAStDwC,UACE,IAAIpC,KAAKiK,YAAYjK,KAAKL,EAAIyC,EAAQpC,KAAKJ,EAAIwC,kCASnDA,UACI,IAAIpC,KAAKiK,YAAYjK,KAAKL,EAAIyC,EAAQpC,KAAKJ,EAAIwC,kCASnDrC,UACKC,KAAKL,IAAMI,EAAKJ,GAAKK,KAAKJ,IAAMG,EAAKH,0CAUjCG,EAAMwL,UAEdvJ,KAAKM,IAAItC,KAAKL,EAAII,EAAKJ,GAAK4L,GAC5BvJ,KAAKM,IAAItC,KAAKJ,EAAIG,EAAKH,GAAK2L,+BAa/BxL,EAAM8D,OACD2H,EAAM,EAAM3H,SAEX,IAAI7D,KAAKiK,YACZjK,KAAKL,EAAI6L,EAAMzL,EAAKJ,EAAIkE,EACxB7D,KAAKJ,EAAI4L,EAAMzL,EAAKH,EAAIiE,wCAUnB9D,OACHsH,EAAKrH,KAAKL,EAAII,EAAKJ,EACnByE,EAAKpE,KAAKJ,EAAIG,EAAKH,SAElBoC,KAAKuD,KAAK8B,EAAKA,EAAKjD,EAAKA,+BAShCrE,UACO,IAAIC,KAAKiK,YACZjI,KAAK3B,IAAIL,KAAKL,EAAGI,EAAKJ,GACtBqC,KAAK3B,IAAIL,KAAKJ,EAAGG,EAAKH,gCAU1BG,UACO,IAAIC,KAAKiK,YACZjI,KAAK1B,IAAIN,KAAKL,EAAGI,EAAKJ,GACtBqC,KAAK1B,IAAIN,KAAKJ,EAAGG,EAAKH,sCAUpB6L,UACC,IAAIzL,KAAKiK,YACZwB,EAAOvG,EAAIlF,KAAKL,EAAI8L,EAAO3C,EAAI9I,KAAKJ,EAAI6L,EAAOnG,EAC/CmG,EAAOrG,EAAIpF,KAAKL,EAAI8L,EAAOpG,EAAIrF,KAAKJ,EAAI6L,EAAOjE,4CAU5C,SAAWxH,KAAKL,EAAI,IAAMK,KAAKJ,EAAI,aClK5C8L,wBAQU/L,EAAGC,kBACND,OAAUQ,IAANR,EAAkBA,EAAI,OAC1BC,OAAUO,IAANP,EAAkBA,EAAI,oDAuBxBoC,KAAKuD,KAAKvF,KAAKL,EAAIK,KAAKL,EAAIK,KAAKJ,EAAII,KAAKJ,8CAS1CI,KAAKL,EAAIK,KAAKL,EAAIK,KAAKJ,EAAII,KAAKJ,8BASvCG,UACOC,KAAKL,EAAII,EAAKJ,EAAIK,KAAKJ,EAAIG,EAAKH,gCASrCG,UACKC,KAAKL,EAAII,EAAKH,EAAII,KAAKJ,EAAIG,EAAKJ,sCAS/BI,UACDC,KAAKL,EAAII,EAAKH,EAAII,KAAKJ,EAAIG,EAAKJ,wCAShCK,KAAK2L,OAAO3L,KAAKI,sCASxBL,UACO,IAAIC,KAAKiK,YAAYjK,KAAKL,EAAII,EAAKJ,EAAGK,KAAKJ,EAAIG,EAAKH,oCAStDG,UACE,IAAIC,KAAKiK,YAAYjK,KAAKL,EAAII,EAAKJ,EAAGK,KAAKJ,EAAIG,EAAKH,oCAStDwC,UACE,IAAIpC,KAAKiK,YAAYjK,KAAKL,EAAIyC,EAAQpC,KAAKJ,EAAIwC,kCASnDA,UACI,IAAIpC,KAAKiK,YAAYjK,KAAKL,EAAIyC,EAAQpC,KAAKJ,EAAIwC,wCAS7CrC,OACLuG,EAAMtG,KAAK4L,IAAI7L,IAASC,KAAKI,SAAWL,EAAKK,UACjDkG,EAAMtE,KAAK1B,KAAK,EAAG0B,KAAK3B,IAAIiG,EAAK,QAC3BuF,EAAU7J,KAAK8J,KAAKxF,UAElBtG,KAAK+L,MAAMhM,GAAQ,GAAQ8L,EAAUA,wCAStC,IAAI7L,KAAKiK,aAAajK,KAAKJ,EAAGI,KAAKL,yCAUhCI,UACHC,KAAKgM,SAAShM,KAAKiM,QAAQlM,oCAS9BA,OACEmM,EAAUlM,KAAK4L,IAAI7L,GAAQA,EAAK6L,IAAI7L,UAEnCA,EAAKoM,SAASD,qCASfT,UACC,IAAIzL,KAAKiK,YACZwB,EAAOvG,EAAIlF,KAAKL,EAAI8L,EAAO3C,EAAI9I,KAAKJ,EACpC6L,EAAOrG,EAAIpF,KAAKL,EAAI8L,EAAOpG,EAAIrF,KAAKJ,kCAUrCG,UAECC,KAAKL,IAAMI,EAAKJ,GAChBK,KAAKJ,IAAMG,EAAKH,0CAWRG,EAAMwL,UAEdvJ,KAAKM,IAAItC,KAAKL,EAAII,EAAKJ,GAAK4L,GAC5BvJ,KAAKM,IAAItC,KAAKJ,EAAIG,EAAKH,GAAK2L,2CAUzB,UAAYvL,KAAKL,EAAI,IAAMK,KAAKJ,EAAI,yCApM7BwJ,EAAIE,UACX,IAAIoC,EACPpC,EAAG3J,EAAIyJ,EAAGzJ,EACV2J,EAAG1J,EAAIwJ,EAAGxJ,YCvBhBwM,wBAgBUlH,EAAGE,EAAG0D,EAAGzD,EAAGC,EAAGkC,kBAClBtC,OAAW/E,IAAN+E,EAAmBA,EAAI,OAC5BE,OAAWjF,IAANiF,EAAmBA,EAAI,OAC5B0D,OAAW3I,IAAN2I,EAAmBA,EAAI,OAC5BzD,OAAWlF,IAANkF,EAAmBA,EAAI,OAC5BC,OAAWnF,IAANmF,EAAmBA,EAAI,OAC5BkC,OAAWrH,IAANqH,EAAmBA,EAAI,6CAyK5BzH,UACDC,KAAKqM,aACEtM,EAGPA,EAAKsM,aACErM,KAGJ,IAAIA,KAAKiK,YACZjK,KAAKkF,EAAInF,EAAKmF,EAAIlF,KAAK8I,EAAI/I,EAAKqF,EAChCpF,KAAKoF,EAAIrF,EAAKmF,EAAIlF,KAAKqF,EAAItF,EAAKqF,EAChCpF,KAAKkF,EAAInF,EAAK+I,EAAI9I,KAAK8I,EAAI/I,EAAKsF,EAChCrF,KAAKoF,EAAIrF,EAAK+I,EAAI9I,KAAKqF,EAAItF,EAAKsF,EAChCrF,KAAKkF,EAAInF,EAAKuF,EAAItF,KAAK8I,EAAI/I,EAAKyH,EAAIxH,KAAKsF,EACzCtF,KAAKoF,EAAIrF,EAAKuF,EAAItF,KAAKqF,EAAItF,EAAKyH,EAAIxH,KAAKwH,wCAUzCxH,KAAKqM,oBACErM,SAGLsM,EAAOtM,KAAKkF,EAAIlF,KAAKqF,EAAIrF,KAAKoF,EAAIpF,KAAK8I,KAEhC,IAATwD,QACM,IAAI5K,MAAM,gCAGd6K,EAAO,EAAMD,EACbE,EAAOxM,KAAKwH,EAAIxH,KAAK8I,EAAI9I,KAAKsF,EAAItF,KAAKqF,EACvCoH,EAAOzM,KAAKsF,EAAItF,KAAKoF,EAAIpF,KAAKwH,EAAIxH,KAAKkF,SAEtC,IAAIlF,KAAKiK,YACZjK,KAAKqF,EAAIkH,GACRvM,KAAKoF,EAAImH,GACTvM,KAAK8I,EAAIyD,EACVvM,KAAKkF,EAAIqH,EACTC,EAAOD,EACPE,EAAOF,qCAWLG,EAAIC,UACH,IAAI3M,KAAKiK,YACZjK,KAAKkF,EACLlF,KAAKoF,EACLpF,KAAK8I,EACL9I,KAAKqF,EACLrF,KAAKkF,EAAIwH,EAAK1M,KAAK8I,EAAI6D,EAAK3M,KAAKsF,EACjCtF,KAAKoF,EAAIsH,EAAK1M,KAAKqF,EAAIsH,EAAK3M,KAAKwH,iCAUnCoF,UACK,IAAI5M,KAAKiK,YACZjK,KAAKkF,EAAI0H,EACT5M,KAAKoF,EAAIwH,EACT5M,KAAK8I,EAAI8D,EACT5M,KAAKqF,EAAIuH,EACT5M,KAAKsF,EACLtF,KAAKwH,mCAWLoF,EAAO/L,OACLwG,EAAKxG,EAAOlB,EAAIiN,EAAQ/L,EAAOlB,EAC/ByE,EAAKvD,EAAOjB,EAAIgN,EAAQ/L,EAAOjB,SAE9B,IAAII,KAAKiK,YACZjK,KAAKkF,EAAI0H,EACT5M,KAAKoF,EAAIwH,EACT5M,KAAK8I,EAAI8D,EACT5M,KAAKqF,EAAIuH,EACT5M,KAAKkF,EAAImC,EAAKrH,KAAK8I,EAAI1E,EAAKpE,KAAKsF,EACjCtF,KAAKoF,EAAIiC,EAAKrH,KAAKqF,EAAIjB,EAAKpE,KAAKwH,2CAWzBqF,EAAQC,UACb,IAAI9M,KAAKiK,YACZjK,KAAKkF,EAAI2H,EACT7M,KAAKoF,EAAIyH,EACT7M,KAAK8I,EAAIgE,EACT9M,KAAKqF,EAAIyH,EACT9M,KAAKsF,EACLtF,KAAKwH,6CAYKqF,EAAQC,EAAQjM,OACxBwG,EAAKxG,EAAOlB,EAAIkN,EAAShM,EAAOlB,EAChCyE,EAAKvD,EAAOjB,EAAIkN,EAASjM,EAAOjB,SAE/B,IAAII,KAAKiK,YACZjK,KAAKkF,EAAI2H,EACT7M,KAAKoF,EAAIyH,EACT7M,KAAK8I,EAAIgE,EACT9M,KAAKqF,EAAIyH,EACT9M,KAAKkF,EAAImC,EAAKrH,KAAK8I,EAAI1E,EAAKpE,KAAKsF,EACjCtF,KAAKoF,EAAIiC,EAAKrH,KAAKqF,EAAIjB,EAAKpE,KAAKwH,kCAUlCqE,OACG/C,EAAI9G,KAAKsE,IAAIuF,GACb/H,EAAI9B,KAAKuE,IAAIsF,UAEZ,IAAI7L,KAAKiK,YACZjK,KAAKkF,EAAI4D,EAAI9I,KAAK8I,EAAIhF,EACtB9D,KAAKoF,EAAI0D,EAAI9I,KAAKqF,EAAIvB,EACtB9D,KAAKkF,GAAKpB,EAAI9D,KAAK8I,EAAIA,EACvB9I,KAAKoF,GAAKtB,EAAI9D,KAAKqF,EAAIyD,EACvB9I,KAAKsF,EACLtF,KAAKwH,oCAWJqE,EAAShL,OACRyF,EAAMtE,KAAKsE,IAAIuF,GACftF,EAAMvE,KAAKuE,IAAIsF,GACfkB,EAAKlM,EAAOlB,EACZqN,EAAKnM,EAAOjB,EAEZsF,EAAIlF,KAAKkF,EAAIoB,EAAMtG,KAAK8I,EAAIvC,EAC5BnB,EAAIpF,KAAKoF,EAAIkB,EAAMtG,KAAKqF,EAAIkB,EAC5BuC,EAAI9I,KAAK8I,EAAIxC,EAAMtG,KAAKkF,EAAIqB,EAC5BlB,EAAIrF,KAAKqF,EAAIiB,EAAMtG,KAAKoF,EAAImB,SAE3B,IAAIvG,KAAKiK,YACZ/E,EACAE,EACA0D,EACAzD,GACCrF,KAAKkF,EAAIA,GAAK6H,GAAM/M,KAAK8I,EAAIA,GAAKkE,EAAKhN,KAAKsF,GAC5CtF,KAAKoF,EAAIA,GAAK2H,GAAM/M,KAAKqF,EAAIA,GAAK2H,EAAKhN,KAAKwH,4CAUpCyF,OACPC,EAAOD,EAAOC,OACdpE,EAAIoE,EAAKvN,EACTmE,EAAIoJ,EAAKtN,SAER,IAAII,KAAKiK,YACZjK,KAAKkF,EAAI4D,EAAI9I,KAAK8I,EAAIhF,EACtB9D,KAAKoF,EAAI0D,EAAI9I,KAAKqF,EAAIvB,EACtB9D,KAAKkF,GAAKpB,EAAI9D,KAAK8I,EAAIA,EACvB9I,KAAKoF,GAAKtB,EAAI9D,KAAKqF,EAAIyD,EACvB9I,KAAKsF,EACLtF,KAAKwH,0CAUF,IAAIxH,KAAKiK,aACXjK,KAAKkF,GACLlF,KAAKoF,EACNpF,KAAK8I,EACL9I,KAAKqF,EACLrF,KAAKsF,EACLtF,KAAKwH,0CAUF,IAAIxH,KAAKiK,YACZjK,KAAKkF,EACLlF,KAAKoF,GACJpF,KAAK8I,GACL9I,KAAKqF,EACNrF,KAAKsF,EACLtF,KAAKwH,iCAUPqE,OACIhI,EAAI7B,KAAKmL,IAAItB,UAEZ,IAAI7L,KAAKiK,YACZjK,KAAKkF,EACLlF,KAAKoF,EACLpF,KAAK8I,EAAI9I,KAAKkF,EAAIrB,EAClB7D,KAAKqF,EAAIrF,KAAKoF,EAAIvB,EAClB7D,KAAKsF,EACLtF,KAAKwH,iCAYPqE,OACIhI,EAAI7B,KAAKmL,IAAItB,UAEZ,IAAI7L,KAAKiK,YACZjK,KAAKkF,EAAIlF,KAAK8I,EAAIjF,EAClB7D,KAAKoF,EAAIpF,KAAKqF,EAAIxB,EAClB7D,KAAK8I,EACL9I,KAAKqF,EACLrF,KAAKsF,EACLtF,KAAKwH,+CAaM,IAAXxH,KAAKkF,GACM,IAAXlF,KAAKoF,GACM,IAAXpF,KAAK8I,GACM,IAAX9I,KAAKqF,GACM,IAAXrF,KAAKsF,GACM,IAAXtF,KAAKwH,gDAUFxH,KAAKkF,EAAIlF,KAAKqF,EAAIrF,KAAKoF,EAAIpF,KAAK8I,GAAM,2CAStC,CACH+D,OAAQ7K,KAAKuD,KAAKvF,KAAKkF,EAAIlF,KAAKkF,EAAIlF,KAAK8I,EAAI9I,KAAK8I,GAClDgE,OAAQ9K,KAAKuD,KAAKvF,KAAKoF,EAAIpF,KAAKoF,EAAIpF,KAAKqF,EAAIrF,KAAKqF,mDAkBhD+H,EAAwB,IAAnBpN,KAAKkF,EAAIlF,KAAKqF,GACnBgI,EAAwB,IAAnBrN,KAAKkF,EAAIlF,KAAKqF,GACnBiI,EAAwB,IAAnBtN,KAAKoF,EAAIpF,KAAK8I,GACnByE,EAAwB,IAAnBvN,KAAKoF,EAAIpF,KAAK8I,GAEnB0E,EAAIxL,KAAKuD,KAAK6H,EAAIA,EAAIG,EAAIA,GAC1BE,EAAIzL,KAAKuD,KAAK8H,EAAIA,EAAIC,EAAIA,GAC1BT,EAASW,EAAIC,EACbX,EAASU,EAAIC,EAEbC,EAAK1L,KAAKqE,MAAMiH,EAAGD,GACnBM,EAAK3L,KAAKqE,MAAMkH,EAAGH,GACnBQ,EAAoB,IAAXD,EAAKD,GACdG,EAAkB,IAAXF,EAAKD,SAEX,CACHI,YAAa9N,KAAKiK,YAAY6D,YAAY9N,KAAKsF,EAAGtF,KAAKwH,GACvDuG,SAAU/N,KAAKiK,YAAY8D,SAASF,GACpCjB,MAAO5M,KAAKiK,YAAY+D,kBAAkBnB,EAAQC,GAClDmB,UAAWjO,KAAKiK,YAAY8D,SAASH,mCAUtC7N,UAECC,KAAKkF,IAAMnF,EAAKmF,GAChBlF,KAAKoF,IAAMrF,EAAKqF,GAChBpF,KAAK8I,IAAM/I,EAAK+I,GAChB9I,KAAKqF,IAAMtF,EAAKsF,GAChBrF,KAAKsF,IAAMvF,EAAKuF,GAChBtF,KAAKwH,IAAMzH,EAAKyH,0CAWRzH,EAAMwL,UAEdvJ,KAAKM,IAAItC,KAAKkF,EAAInF,EAAKmF,GAAKqG,GAC5BvJ,KAAKM,IAAItC,KAAKoF,EAAIrF,EAAKqF,GAAKmG,GAC5BvJ,KAAKM,IAAItC,KAAK8I,EAAI/I,EAAK+I,GAAKyC,GAC5BvJ,KAAKM,IAAItC,KAAKqF,EAAItF,EAAKsF,GAAKkG,GAC5BvJ,KAAKM,IAAItC,KAAKsF,EAAIvF,EAAKuF,GAAKiG,GAC5BvJ,KAAKM,IAAItC,KAAKwH,EAAIzH,EAAKyH,GAAK+D,2CAUzB,UAAY,CAACvL,KAAKkF,EAAGlF,KAAKoF,EAAGpF,KAAK8I,EAAG9I,KAAKqF,EAAGrF,KAAKsF,EAAGtF,KAAKwH,GAAG7G,KAAK,KAAO,0CAljBjE+L,EAAIC,UACZ,IAAIP,EAAS,EAAG,EAAG,EAAG,EAAGM,EAAIC,mCASzBC,UACJ,IAAIR,EAASQ,EAAO,EAAG,EAAGA,EAAO,EAAG,qCAU9BA,EAAO/L,UACb,IAAIuL,EACPQ,EACA,EACA,EACAA,EACA/L,EAAOlB,EAAIkB,EAAOlB,EAAIiN,EACtB/L,EAAOjB,EAAIiB,EAAOjB,EAAIgN,6CAYLC,EAAQC,UACtB,IAAIV,EAASS,EAAQ,EAAG,EAAGC,EAAQ,EAAG,+CAWtBD,EAAQC,EAAQjM,UAChC,IAAIuL,EACPS,EACA,EACA,EACAC,EACAjM,EAAOlB,EAAIkB,EAAOlB,EAAIkN,EACtBhM,EAAOjB,EAAIiB,EAAOjB,EAAIkN,oCAUdjB,OACN/C,EAAI9G,KAAKsE,IAAIuF,GACb/H,EAAI9B,KAAKuE,IAAIsF,UAEZ,IAAIO,EAAStD,EAAGhF,GAAIA,EAAGgF,EAAG,EAAG,sCAUtB+C,EAAShL,OACjBiI,EAAI9G,KAAKsE,IAAIuF,GACb/H,EAAI9B,KAAKuE,IAAIsF,UAEZ,IAAIO,EACPtD,EACAhF,GACCA,EACDgF,EACAjI,EAAOlB,EAAIkB,EAAOlB,EAAImJ,EAAIjI,EAAOjB,EAAIkE,EACrCjD,EAAOjB,EAAIiB,EAAOjB,EAAIkJ,EAAIjI,EAAOlB,EAAImE,8CAUnBmJ,OAChBC,EAAOD,EAAOC,OACdpE,EAAIoE,EAAKvN,EACTmE,EAAIoJ,EAAKtN,SAER,IAAIwM,EAAStD,EAAGhF,GAAIA,EAAGgF,EAAG,EAAG,0CAS7B,IAAIsD,GAAU,EAAG,EAAG,EAAG,EAAG,EAAG,0CAS7B,IAAIA,EAAS,EAAG,EAAG,GAAI,EAAG,EAAG,iCAS3BP,UAGF,IAAIO,EAAS,EAAG,EAFbpK,KAAKmL,IAAItB,GAEU,EAAG,EAAG,iCAS1BA,UAGF,IAAIO,EAAS,EAFVpK,KAAKmL,IAAItB,GAEO,EAAG,EAAG,EAAG,YAqa3CO,EAAS8B,SAAW,IAAI9B,EACxBA,EAAS8B,SAAS7B,WAAa,kBAAM,OCzlB/B8B,wBAQU/E,EAAIE,EAAI8E,EAAIC,kBACfjF,GAAKA,OACLE,GAAKA,OACL8E,GAAKA,OACLC,GAAKA,wDASMxK,OAIVyK,EAAKtO,KAAKoJ,GAAGmF,KAAKvO,KAAKsJ,GAAIzF,GAC3B2K,EAAKxO,KAAKsJ,GAAGiF,KAAKvO,KAAKoO,GAAIvK,GAC3B4K,EAAKzO,KAAKoO,GAAGG,KAAKvO,KAAKqO,GAAIxK,GAG3B6K,EAAKJ,EAAGC,KAAKC,EAAI3K,GACjB8K,EAAKH,EAAGD,KAAKE,EAAI5K,UAEhB6K,EAAGH,KAAKI,EAAI9K,4CASNA,OAEPyK,EAAKtO,KAAKoJ,GAAGmF,KAAKvO,KAAKsJ,GAAIzF,GAC3B2K,EAAKxO,KAAKsJ,GAAGiF,KAAKvO,KAAKoO,GAAIvK,GAC3B4K,EAAKzO,KAAKoO,GAAGG,KAAKvO,KAAKqO,GAAIxK,GAG3B6K,EAAKJ,EAAGC,KAAKC,EAAI3K,GACjB8K,EAAKH,EAAGD,KAAKE,EAAI5K,GAGjB+K,EAAMF,EAAGH,KAAKI,EAAI9K,SAEjB,CACH,IAAIsK,EAAcnO,KAAKoJ,GAAIkF,EAAII,EAAIE,GACnC,IAAIT,EAAcS,EAAKD,EAAIF,EAAIzO,KAAKqO,2DAUpCnJ,EAAGE,EAAG0D,EAaV5D,EAAIlF,KAAKoJ,GAAG+C,UAAU,GACtB/G,EAAIpF,KAAKsJ,GAAG6C,SAAS,GACrBrD,EAAI9I,KAAKoO,GAAGjC,UAAU,OAChB3G,EAAKN,EAAE2J,IAAIzJ,EAAEyJ,IAAI/F,EAAE+F,IAAI7O,KAAKqO,MAElCnJ,EAAIlF,KAAKoJ,GAAG+C,SAAS,GACrB/G,EAAIpF,KAAKsJ,GAAG6C,UAAU,GACtBrD,EAAI9I,KAAKoO,GAAGjC,SAAS,OACf1G,EAAKP,EAAE2J,IAAIzJ,EAAEyJ,IAAI/F,IAEvB5D,EAAIlF,KAAKoJ,GAAG+C,UAAU,GACtB/G,EAAIpF,KAAKsJ,GAAG6C,SAAS,OACfzG,EAAKR,EAAE2J,IAAIzJ,GAEX0J,EAAK9O,KAAKoJ,SAET,CACHzJ,EAAG,IAAIsB,EAAWuE,EAAG7F,EAAG8F,EAAG9F,EAAG+F,EAAG/F,EAAGmP,EAAGnP,GACvCC,EAAG,IAAIqB,EAAWuE,EAAG5F,EAAG6F,EAAG7F,EAAG8F,EAAG9F,EAAGkP,EAAGlP,yDAetCI,KAAK+O,eAAe,uBAAwB,KACzC7J,EAAGE,EAAG0D,EAGV5D,EAAIlF,KAAKoJ,GAAG+C,UAAU,GACtB/G,EAAIpF,KAAKsJ,GAAG6C,SAAS,GACrBrD,EAAI9I,KAAKoO,GAAGjC,UAAU,OAChB3G,EAAKN,EAAE2J,IAAIzJ,EAAEyJ,IAAI/F,EAAE+F,IAAI7O,KAAKqO,MAElCnJ,EAAIlF,KAAKoJ,GAAG+C,SAAS,GACrB/G,EAAIpF,KAAKsJ,GAAG6C,UAAU,GACtBrD,EAAI9I,KAAKoO,GAAGjC,SAAS,OACf1G,EAAKP,EAAE2J,IAAIzJ,EAAEyJ,IAAI/F,IAEvB5D,EAAIlF,KAAKoJ,GAAG+C,UAAU,GACtB/G,EAAIpF,KAAKsJ,GAAG6C,SAAS,OACfzG,EAAKR,EAAE2J,IAAIzJ,QAKZ4J,oBAAsB,IAAI3D,EAC3B,GAAK7F,EAAG7F,EAAI6F,EAAG7F,EAAI6F,EAAG5F,EAAI4F,EAAG5F,GAC7B,IAAM6F,EAAG9F,EAAI6F,EAAG7F,EAAI8F,EAAG7F,EAAI4F,EAAG5F,GAC9B,GAAK6F,EAAG9F,EAAI8F,EAAG9F,EAAI8F,EAAG7F,EAAI6F,EAAG7F,GAAK,GAAK8F,EAAG/F,EAAI6F,EAAG7F,EAAI+F,EAAG9F,EAAI4F,EAAG5F,GAC/D,GAAK8F,EAAG/F,EAAI8F,EAAG9F,EAAI+F,EAAG9F,EAAI6F,EAAG7F,GAC7B8F,EAAG/F,EAAI+F,EAAG/F,EAAI+F,EAAG9F,EAAI8F,EAAG9F,QAGvBqP,UAAYjP,KAAKgP,oBAAoBE,QAAQ,EAAG,UAIlDlP,KAAKgP,sEASUC,OAKlBtN,EADEqN,EAAsBhP,KAAKmP,4BAG7BF,GAAa,EACbtN,EAAS,OAER,GAAIsN,GAAajP,KAAKiP,UACvBtN,EAAS,MAER,CAIDA,EAASsN,EAAYjP,KAAKiP,cAErB,IAAI1O,EAAI,EAAGA,GAJC,GAIcA,IAAK,KAC1B4J,EAAO6E,EAAoBE,QAAQ,EAAGvN,GAAUsN,KAElDjN,KAAKM,IAAI6H,GARC,eAYRhH,EAAQ6L,EAAoBvM,KAAKd,MAEzB,IAAVwB,QAIJxB,GAAUwI,EAAOhH,UAIlBxB,+CASDyN,EAAQpP,KAAKqP,0BACbhI,EAAK+H,EAAMzP,EAAEqF,gBACbZ,EAAKgL,EAAMxP,EAAEoF,gBACfH,EAAQwC,EAAGpC,mBAAmB,EAAG,GAErCJ,EAAQA,EAAM8C,OAAOvD,EAAGa,mBAAmB,EAAG,QAG1C5E,EAAML,KAAKoJ,GAAG/I,IAAIL,KAAKqO,IACvB/N,EAAMN,KAAKoJ,GAAG9I,IAAIN,KAAKqO,WAG3BxJ,EAAMyK,QAAQ,SAASzL,MACf,GAAKA,GAAKA,GAAK,EAAG,KACZ0L,EAAY,IAAIjE,EAClB8D,EAAMzP,EAAE8C,KAAKoB,GACbuL,EAAMxP,EAAE6C,KAAKoB,IAGjBxD,EAAMA,EAAIA,IAAIkP,GACdjP,EAAMA,EAAIA,IAAIiP,MAIf,IAAI7P,EACPW,EAAIV,EACJU,EAAIT,EACJU,EAAIX,EAAIU,EAAIV,EACZW,EAAIV,EAAIS,EAAIT,yDAUT,CACH4P,KAAMxP,KAAKyP,mBAAmBC,iBAC9BC,WAAW,IAAIvD,GACV0B,YAAY9N,KAAKoJ,GAAGzJ,EAAGK,KAAKoJ,GAAGxJ,GAC/BgQ,iBAAiBlE,EAASmE,WAAW7P,KAAKoJ,GAAIpJ,KAAKqO,qDAUtD5C,EAASW,EACV0B,YAAY9N,KAAKoJ,GAAGzJ,EAAGK,KAAKoJ,GAAGxJ,GAC/BgQ,iBAAiBlE,EAASmE,WAAW7P,KAAKoJ,GAAIpJ,KAAKqO,KACnDyB,iBAGE,IAAI3B,EACPnO,KAAKoJ,GAAGuG,UAAUlE,GAClBzL,KAAKsJ,GAAGqG,UAAUlE,GAClBzL,KAAKoO,GAAGuB,UAAUlE,GAClBzL,KAAKqO,GAAGsB,UAAUlE,wCAUdsE,OACF7P,EAAS,GACT8P,EAAa,IAAItE,EAAS,EAAG,UAEnCqE,OAAwB5P,IAAb4P,EAAyBA,EAAW,EAG/C7P,EAAOkB,KAAKpB,KAAKoJ,aASR6G,EAAkB7G,EAAIE,EAAI8E,EAAIC,OAE7BC,EAAKlF,EAAGmF,KAAKjF,EAAI,IACjBkF,EAAKlF,EAAGiF,KAAKH,EAAI,IACjBK,EAAKL,EAAGG,KAAKF,EAAI,IAGjBK,EAAKJ,EAAGC,KAAKC,EAAI,IACjBG,EAAKH,EAAGD,KAAKE,EAAI,IAGjBG,EAAMF,EAAGH,KAAKI,EAAI,IAElBuB,EAAWxE,EAASmE,WAAWzG,EAAIiF,GACnC8B,EAAWzE,EAASmE,WAAWzG,EAAIE,GACnC8G,EAAW1E,EAASmE,WAAWxB,EAAID,GACrCrM,EAAO,GAEyB,IAAhCiO,EAAWK,OAAOF,KAGlBpO,EAFsBmO,EAASI,cAAcH,GAExB/P,cAEW,IAAhC4P,EAAWK,OAAOD,GAAqB,KACjCE,EAAgBJ,EAASI,cAAcF,GAE7CrO,EAAOC,KAAK1B,IAAIyB,EAAMuO,EAAclQ,UAGpC2B,EAAOgO,GACPE,EAAkB7G,EAAIkF,EAAII,EAAIE,GAC9B1O,EAAOkB,KAAK,IAAIkK,EAAQsD,EAAIjP,EAAGiP,EAAIhP,IACnCqQ,EAAkBrB,EAAKD,EAAIF,EAAIJ,IAG/BnO,EAAOkB,KAAK,IAAIkK,EAAQsD,EAAIjP,EAAGiP,EAAIhP,IAK3CqQ,CAAkBjQ,KAAKoJ,GAAIpJ,KAAKsJ,GAAItJ,KAAKoO,GAAIpO,KAAKqO,IAGlDnO,EAAOkB,KAAKpB,KAAKqO,IAEV,IAAIpO,EAAUC,4CAUjB,IAAMF,KAAKoJ,GAAGzJ,EAAI,IAAMK,KAAKoJ,GAAGxJ,EAAI,KAC9BI,KAAKsJ,GAAG3J,EAAI,IAAMK,KAAKsJ,GAAG1J,EAChC,IAAMI,KAAKoO,GAAGzO,EAAI,IAAMK,KAAKoO,GAAGxO,EAChC,IAAMI,KAAKqO,GAAG1O,EAAI,IAAMK,KAAKqO,GAAGzO,WC3VtC2Q,wBAOU1P,EAAQ2P,EAASC,kBACpB5P,OAASA,OACT2P,QAAUA,OACVC,QAAUA,4DASR,IAAI/Q,EACPM,KAAKa,OAAOlB,EAAIK,KAAKwQ,QACrBxQ,KAAKa,OAAOjB,EAAII,KAAKyQ,QACN,EAAfzQ,KAAKwQ,QACU,EAAfxQ,KAAKyQ,sDAUF,IAAIxQ,WClCbyQ,wBAMUtH,EAAIE,kBACPF,GAAKA,OACLE,GAAKA,yDASJjJ,EAAML,KAAKoJ,GAAG/I,IAAIL,KAAKsJ,IACvBhJ,EAAMN,KAAKoJ,GAAG9I,IAAIN,KAAKsJ,WAEtB,IAAI5J,EACPW,EAAIV,EACJU,EAAIT,EACJU,EAAIX,EAAIU,EAAIV,EACZW,EAAIV,EAAIS,EAAIT,gDAUT,IAAIK,EAAU,CAACD,KAAKoJ,GAAIpJ,KAAKsJ,cChCtCqH,wBAOUvH,EAAIE,EAAI8E,kBACXhF,GAAKA,OACLE,GAAKA,OACL8E,GAAKA,wDASMvK,OAIVwK,EAAKrO,KAAKoJ,GAAGmF,KAAKvO,KAAKsJ,GAAIzF,GAC3ByK,EAAKtO,KAAKsJ,GAAGiF,KAAKvO,KAAKoO,GAAIvK,UAE1BwK,EAAGE,KAAKD,EAAIzK,4CASNA,OAEPwK,EAAKrO,KAAKoJ,GAAGmF,KAAKvO,KAAKsJ,GAAIzF,GAC3ByK,EAAKtO,KAAKsJ,GAAGiF,KAAKvO,KAAKoO,GAAIvK,GAG3B2K,EAAKH,EAAGE,KAAKD,EAAIzK,SAEhB,CACH,IAAI8M,EAAkB3Q,KAAKoJ,GAAIiF,EAAIG,GACnC,IAAImC,EAAkBnC,EAAIF,EAAItO,KAAKoO,2DAUnClJ,EAEJA,EAAIlF,KAAKsJ,GAAG6C,UAAU,OAChB1G,EAAKzF,KAAKoJ,GAAGyF,IAAI3J,EAAE2J,IAAI7O,KAAKoO,KAElClJ,EAAIlF,KAAKoJ,GAAG+C,UAAU,OAChB/G,EAAIpF,KAAKsJ,GAAG6C,SAAS,GACrBzG,EAAKR,EAAE2J,IAAIzJ,GAEX0J,EAAK9O,KAAKoJ,SAET,CACHzJ,EAAG,IAAIsB,EAAWwE,EAAG9F,EAAG+F,EAAG/F,EAAGmP,EAAGnP,GACjCC,EAAG,IAAIqB,EAAWwE,EAAG7F,EAAG8F,EAAG9F,EAAGkP,EAAGlP,yDAWhCI,KAAK+O,eAAe,uBAAwB,KACzC7J,EAEJA,EAAIlF,KAAKsJ,GAAG6C,UAAU,OAChB1G,EAAKzF,KAAKoJ,GAAGyF,IAAI3J,EAAE2J,IAAI7O,KAAKoO,KAElClJ,EAAIlF,KAAKoJ,GAAG+C,UAAU,OAChB/G,EAAIpF,KAAKsJ,GAAG6C,SAAS,GACrBzG,EAAKR,EAAE2J,IAAIzJ,QAKZ4J,oBAAsB,IAAI3D,EAC3B,GAAK5F,EAAG9F,EAAI8F,EAAG9F,EAAI8F,EAAG7F,EAAI6F,EAAG7F,GAC7B,GAAK8F,EAAG/F,EAAI8F,EAAG9F,EAAI+F,EAAG9F,EAAI6F,EAAG7F,GAC7B8F,EAAG/F,EAAI+F,EAAG/F,EAAI+F,EAAG9F,EAAI8F,EAAG9F,QAIvBqP,UAAYjP,KAAKgP,oBAAoB4B,QAAQ,EAAG,UAGlD5Q,KAAKgP,sEASUC,OAKlBtN,EADEqN,EAAsBhP,KAAKmP,4BAG7BF,GAAa,EACbtN,EAAS,OAER,GAAIsN,GAAajP,KAAKiP,UACvBtN,EAAS,MAER,CAIDA,EAASsN,EAAYjP,KAAKiP,cAErB,IAAI1O,EAAI,EAAGA,GAJC,GAIcA,IAAK,KAC1B4J,EAAO6E,EAAoBE,QAAQ,EAAGvN,GAAUsN,KAElDjN,KAAKM,IAAI6H,GARC,eAYRhH,EAAQ6L,EAAoBvM,KAAKd,MAEzB,IAAVwB,QAIJxB,GAAUwI,EAAOhH,UAIlBxB,+CASDyN,EAAQpP,KAAKqP,0BACbhI,EAAK+H,EAAMzP,EAAEqF,gBACbZ,EAAKgL,EAAMxP,EAAEoF,gBACfH,EAAQwC,EAAGpC,mBAAmB,EAAG,GACrCJ,EAAQA,EAAM8C,OAAOvD,EAAGa,mBAAmB,EAAG,QAE1C5E,EAAML,KAAKoJ,GAAG/I,IAAIL,KAAKoO,IACvB9N,EAAMN,KAAKoJ,GAAG9I,IAAIN,KAAKoO,WAE3BvJ,EAAMyK,QAAQ,SAASzL,MACf,GAAKA,GAAKA,GAAK,EAAG,KACZ0L,EAAY,IAAIjE,EAClB8D,EAAMzP,EAAE8C,KAAKoB,GACbuL,EAAMxP,EAAE6C,KAAKoB,IAGjBxD,EAAMA,EAAIA,IAAIkP,GACdjP,EAAMA,EAAIA,IAAIiP,MAIf,IAAI7P,EACPW,EAAIV,EACJU,EAAIT,EACJU,EAAIX,EAAIU,EAAIV,EACZW,EAAIV,EAAIS,EAAIT,yDAUT,CACH4P,KAAMxP,KAAKyP,mBAAmBC,iBAC9BC,UAAWvD,EACN0B,YAAY9N,KAAKoJ,GAAGzJ,EAAGK,KAAKoJ,GAAGxJ,GAC/BgQ,iBAAiBlE,EAASmE,WAAW7P,KAAKoJ,GAAIpJ,KAAKoO,qDAUtD3C,EAASW,EACV0B,YAAY9N,KAAKoJ,GAAGzJ,EAAGK,KAAKoJ,GAAGxJ,GAC/BgQ,iBAAiBlE,EAASmE,WAAW7P,KAAKoJ,GAAIpJ,KAAKoO,KACnD0B,iBAGE,IAAIa,EACP3Q,KAAKoJ,GAAGuG,UAAUlE,GAClBzL,KAAKsJ,GAAGqG,UAAUlE,GAClBzL,KAAKoO,GAAGuB,UAAUlE,wCAUdsE,OACF7P,EAAS,GACT8P,EAAa,IAAItE,EAAS,EAAG,UAEnCqE,OAAwB5P,IAAb4P,EAAyBA,EAAW,EAG/C7P,EAAOkB,KAAKpB,KAAKoJ,aAQR6G,EAAkB7G,EAAIE,EAAI8E,OAEzBC,EAAKjF,EAAGmF,KAAKjF,EAAI,IACjBgF,EAAKhF,EAAGiF,KAAKH,EAAI,IAGjBI,EAAKH,EAAGE,KAAKD,EAAI,IAEjB4B,EAAWxE,EAASmE,WAAWzG,EAAIgF,GACnCyC,EAAUnF,EAASmE,WAAWzG,EAAIE,GACpCvH,EAAO,GAEwB,IAA/BiO,EAAWK,OAAOQ,KAGlB9O,EAFsBmO,EAASI,cAAcO,GAExBzQ,UAGrB2B,EAAOgO,GACPE,EAAkB7G,EAAIiF,EAAIG,GAC1BtO,EAAOkB,KAAK,IAAIkK,EAAQkD,EAAG7O,EAAG6O,EAAG5O,IACjCqQ,EAAkBzB,EAAIF,EAAIF,IAG1BlO,EAAOkB,KAAK,IAAIkK,EAAQkD,EAAG7O,EAAG6O,EAAG5O,IAKzCqQ,CAAkBjQ,KAAKoJ,GAAIpJ,KAAKsJ,GAAItJ,KAAKoO,IAGzClO,EAAOkB,KAAKpB,KAAKoO,IAEV,IAAInO,EAAUC,4CAUjB,IAAMF,KAAKoJ,GAAGzJ,EAAI,IAAMK,KAAKoJ,GAAGxJ,EAAI,KAC9BI,KAAKsJ,GAAG3J,EAAI,IAAMK,KAAKsJ,GAAG1J,EAChC,IAAMI,KAAKoO,GAAGzO,EAAI,IAAMK,KAAKoO,GAAGxO,WC9RtCkR,wBAQUnR,EAAGC,EAAGC,EAAOC,kBAChBH,EAAIA,OACJC,EAAIA,OACJC,MAAQA,OACRC,OAASA,4DASP,IAAIJ,EACPM,KAAKL,EACLK,KAAKJ,EACLI,KAAKH,MACLG,KAAKF,qDAUF,IAAIG,EAAU,CACjB,IAAIqL,EAAQtL,KAAKL,EAAGK,KAAKJ,GACzB,IAAI0L,EAAQtL,KAAKL,EAAIK,KAAKH,MAAOG,KAAKJ,GACtC,IAAI0L,EAAQtL,KAAKL,EAAIK,KAAKH,MAAOG,KAAKJ,EAAII,KAAKF,QAC/C,IAAIwL,EAAQtL,KAAKL,EAAGK,KAAKJ,EAAII,KAAKF"}