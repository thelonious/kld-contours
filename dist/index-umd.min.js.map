{"version":3,"file":"index-umd.min.js","sources":["../lib/BoundingBox2D.js","../lib/Polygon2D.js","../lib/Circle2D.js","../node_modules/kld-polynomial/lib/Polynomial.js","../node_modules/kld-polynomial/lib/SqrtPolynomial.js","../node_modules/kld-affine/lib/Point2D.js","../node_modules/kld-affine/lib/Vector2D.js","../node_modules/kld-affine/lib/Matrix2D.js","../lib/CubicBezier2D.js","../lib/Ellipse2D.js","../lib/Line2D.js","../lib/QuadraticBezier2D.js","../lib/Rectangle2D.js"],"sourcesContent":["/**\n *  BoundingBox2D.js\n *\n *  @module BoundingBox2D\n *  @copyright 2011-2019 Kevin Lindsey\n */\n\n/**\n *  BoundingBox2D\n */\nclass BoundingBox2D {\n    /**\n     *  @param {number} x\n     *  @param {number} y\n     *  @param {number} width\n     *  @param {number} height\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     *  overlaps\n     *\n     *  @param {module:kld-contours~BoundingBox2D} that\n     *  @returns {boolean}\n     */\n    overlaps(that) {\n        return (\n            this.x < (that.x + that.width) && (this.x + this.width) > that.x &&\n            this.y < (that.y + that.height) && (this.y + this.height) > that.y\n        );\n    }\n\n    /**\n     *  isEmpty\n     *\n     *  @returns {boolean}\n     */\n    isEmpty() {\n        return this.width !== 0 && this.height !== 0;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return (\n            \"bbox(\" +\n            this.x + \",\" +\n            this.y + \",\" +\n            this.width + \",\" +\n            this.height + \")\"\n        );\n    }\n}\n\nexport default BoundingBox2D;\n","/**\n *  Polygon2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Polygon2D\n */\nimport BoundingBox2D from \"./BoundingBox2D.js\";\n\n/**\n *  Polygon2D\n */\nclass Polygon2D {\n    /**\n     *  @param {Array<module:kld-affine.Point2D>} points\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    constructor(points) {\n        this.points = (points !== undefined) ? points : [];\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        if (this.points.length > 0) {\n            let min = this.points[0];\n            let max = this.points[0];\n\n            for (let i = 1; i < this.points.length; i++) {\n                const point = this.points[i];\n\n                min = min.min(point);\n                max = max.max(point);\n            }\n\n            return new BoundingBox2D(\n                min.x,\n                min.y,\n                max.x - min.x,\n                max.y - max.y\n            );\n        }\n\n        return new BoundingBox2D(0, 0, 0, 0);\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return this;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return this.points.map(p => {\n            return `${p.x}, ${p.y}`;\n        }).join(\" \");\n    }\n}\n\nexport default Polygon2D;\n","/* eslint-disable class-methods-use-this */\n/**\n *  Circle2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Circle2D\n */\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  Circle2D\n */\nclass Circle2D {\n    /**\n     *  @param {module:kld-affine.Point2D} center\n     *  @param {number} radius\n     *  @returns {module:kld-contours~Circle2D}\n     */\n    constructor(center, radius) {\n        this.center = center;\n        this.radius = radius;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        return new BoundingBox2D(\n            this.center.x - this.radius,\n            this.center.y - this.radius,\n            this.radius * 2.0,\n            this.radius * 2.0\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return new Polygon2D();\n    }\n}\n\nexport default Circle2D;\n","/* eslint-disable camelcase */\n/**\n *  Polynomial.js\n *\n *  @module Polynomial\n *  @copyright 2002-2019 Kevin Lindsey<br>\n *  -<br>\n *  Contribution {@link http://github.com/Quazistax/kld-polynomial}<br>\n *  copyright 2015 Robert Benko (Quazistax) <quazistax@gmail.com><br>\n *  MIT license\n */\n\n/**\n *  Sign of a number (+1, -1, +0, -0).\n *\n *  @param {number} x\n *  @returns {number}\n */\nfunction sign(x) {\n    // eslint-disable-next-line no-self-compare\n    return typeof x === \"number\" ? x ? x < 0 ? -1 : 1 : x === x ? x : NaN : NaN;\n}\n\n/**\n *  Polynomial\n *\n *  @memberof module:kld-polynomial\n */\nclass Polynomial {\n    /**\n     *  Polynomial\n     *\n     *  @param {Array<number>} coefs\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    constructor(...coefs) {\n        this.coefs = [];\n\n        for (let i = coefs.length - 1; i >= 0; i--) {\n            this.coefs.push(coefs[i]);\n        }\n\n        this._variable = \"t\";\n        this._s = 0;\n    }\n\n    /**\n     *  Based on polint in \"Numerical Recipes in C, 2nd Edition\", pages 109-110\n     *\n     *  @param {Array<number>} xs\n     *  @param {Array<number>} ys\n     *  @param {number} n\n     *  @param {number} offset\n     *  @param {number} x\n     *\n     *  @returns {{y: number, dy: number}}\n     */\n    static interpolate(xs, ys, n, offset, x) {\n        if (xs.constructor !== Array || ys.constructor !== Array) {\n            throw new TypeError(\"xs and ys must be arrays\");\n        }\n        if (isNaN(n) || isNaN(offset) || isNaN(x)) {\n            throw new TypeError(\"n, offset, and x must be numbers\");\n        }\n\n        let i, y;\n        let dy = 0;\n        const c = new Array(n);\n        const d = new Array(n);\n        let ns = 0;\n\n        let diff = Math.abs(x - xs[offset]);\n\n        for (i = 0; i < n; i++) {\n            const dift = Math.abs(x - xs[offset + i]);\n\n            if (dift < diff) {\n                ns = i;\n                diff = dift;\n            }\n            c[i] = d[i] = ys[offset + i];\n        }\n\n        y = ys[offset + ns];\n        ns--;\n\n        for (let m = 1; m < n; m++) {\n            for (i = 0; i < n - m; i++) {\n                const ho = xs[offset + i] - x;\n                const hp = xs[offset + i + m] - x;\n                const w = c[i + 1] - d[i];\n                let den = ho - hp;\n\n                if (den === 0.0) {\n                    throw new RangeError(\"Unable to interpolate polynomial. Two numbers in n were identical (to within roundoff)\");\n                }\n\n                den = w / den;\n                d[i] = hp * den;\n                c[i] = ho * den;\n            }\n\n            dy = (2 * (ns + 1) < (n - m)) ? c[ns + 1] : d[ns--];\n            y += dy;\n        }\n\n        return {y, dy};\n    }\n\n    /**\n     *  Newton's (Newton-Raphson) method for finding Real roots on univariate function. <br/>\n     *  When using bounds, algorithm falls back to secant if newton goes out of range.\n     *  Bisection is fallback for secant when determined secant is not efficient enough.\n     *  @see {@link http://en.wikipedia.org/wiki/Newton%27s_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Secant_method}\n     *  @see {@link http://en.wikipedia.org/wiki/Bisection_method}\n     *\n     *  @param {number} x0 - Initial root guess\n     *  @param {Function} f - Function which root we are trying to find\n     *  @param {Function} df - Derivative of function f\n     *  @param {number} max_iterations - Maximum number of algorithm iterations\n     *  @param {number} [min] - Left bound value\n     *  @param {number} [max] - Right bound value\n     *  @returns {number} root\n     */\n    static newtonSecantBisection(x0, f, df, max_iterations, min, max) {\n        let x, prev_dfx = 0, dfx, prev_x_ef_correction = 0, x_correction, x_new;\n        let y, y_atmin, y_atmax;\n\n        x = x0;\n\n        const ACCURACY = 14;\n        const min_correction_factor = Math.pow(10, -ACCURACY);\n        const isBounded = (typeof min === \"number\" && typeof max === \"number\");\n\n        if (isBounded) {\n            if (min > max) {\n                throw new RangeError(\"Min must be greater than max\");\n            }\n\n            y_atmin = f(min);\n            y_atmax = f(max);\n\n            if (sign(y_atmin) === sign(y_atmax)) {\n                throw new RangeError(\"Y values of bounds must be of opposite sign\");\n            }\n        }\n\n        const isEnoughCorrection = function() {\n            // stop if correction is too small or if correction is in simple loop\n            return (Math.abs(x_correction) <= min_correction_factor * Math.abs(x)) ||\n                (prev_x_ef_correction === (x - x_correction) - x);\n        };\n\n        for (let i = 0; i < max_iterations; i++) {\n            dfx = df(x);\n\n            if (dfx === 0) {\n                if (prev_dfx === 0) {\n                    // error\n                    throw new RangeError(\"df(x) is zero\");\n                }\n                else {\n                    // use previous derivation value\n                    dfx = prev_dfx;\n                }\n                // or move x a little?\n                // dfx = df(x != 0 ? x + x * 1e-15 : 1e-15);\n            }\n\n            prev_dfx = dfx;\n            y = f(x);\n            x_correction = y / dfx;\n            x_new = x - x_correction;\n\n            if (isEnoughCorrection()) {\n                break;\n            }\n\n            if (isBounded) {\n                if (sign(y) === sign(y_atmax)) {\n                    max = x;\n                    y_atmax = y;\n                }\n                else if (sign(y) === sign(y_atmin)) {\n                    min = x;\n                    y_atmin = y;\n                }\n                else {\n                    x = x_new;\n                    break;\n                }\n\n                if ((x_new < min) || (x_new > max)) {\n                    if (sign(y_atmin) === sign(y_atmax)) {\n                        break;\n                    }\n\n                    const RATIO_LIMIT = 50;\n                    const AIMED_BISECT_OFFSET = 0.25; // [0, 0.5)\n                    const dy = y_atmax - y_atmin;\n                    const dx = max - min;\n\n                    if (dy === 0) {\n                        x_correction = x - (min + dx * 0.5);\n                    }\n                    else if (Math.abs(dy / Math.min(y_atmin, y_atmax)) > RATIO_LIMIT) {\n                        x_correction = x - (min + dx * (0.5 + (Math.abs(y_atmin) < Math.abs(y_atmax) ? -AIMED_BISECT_OFFSET : AIMED_BISECT_OFFSET)));\n                    }\n                    else {\n                        x_correction = x - (min - y_atmin / dy * dx);\n                    }\n                    x_new = x - x_correction;\n\n                    if (isEnoughCorrection()) {\n                        break;\n                    }\n                }\n            }\n\n            prev_x_ef_correction = x - x_new;\n            x = x_new;\n        }\n\n        return x;\n    }\n\n    /**\n     *  Clones this polynomial and return the clone.\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    clone() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice();\n\n        return poly;\n    }\n\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     */\n    eval(x) {\n        if (isNaN(x)) {\n            throw new TypeError(`Parameter must be a number. Found '${x}'`);\n        }\n\n        let result = 0;\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            result = result * x + this.coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    add(that) {\n        const result = new Polynomial();\n        const d1 = this.getDegree();\n        const d2 = that.getDegree();\n        const dmax = Math.max(d1, d2);\n\n        for (let i = 0; i <= dmax; i++) {\n            const v1 = (i <= d1) ? this.coefs[i] : 0;\n            const v2 = (i <= d2) ? that.coefs[i] : 0;\n\n            result.coefs[i] = v1 + v2;\n        }\n\n        return result;\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-polynomial.Polynomial} that\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    multiply(that) {\n        const result = new Polynomial();\n\n        for (let i = 0; i <= this.getDegree() + that.getDegree(); i++) {\n            result.coefs.push(0);\n        }\n\n        for (let i = 0; i <= this.getDegree(); i++) {\n            for (let j = 0; j <= that.getDegree(); j++) {\n                result.coefs[i + j] += this.coefs[i] * that.coefs[j];\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  divideEqualsScalar\n     *\n     *  @deprecated To be replaced by divideScalar\n     *  @param {number} scalar\n     */\n    divideEqualsScalar(scalar) {\n        for (let i = 0; i < this.coefs.length; i++) {\n            this.coefs[i] /= scalar;\n        }\n    }\n\n    /**\n     *  simplifyEquals\n     *\n     *  @deprecated To be replaced by simplify\n     *  @param {number} TOLERANCE\n     */\n    simplifyEquals(TOLERANCE = 1e-12) {\n        for (let i = this.getDegree(); i >= 0; i--) {\n            if (Math.abs(this.coefs[i]) <= TOLERANCE) {\n                this.coefs.pop();\n            }\n            else {\n                break;\n            }\n        }\n    }\n\n    /**\n     *  Sets small coefficients to zero.\n     *\n     *  @deprecated To be replaced by removeZeros\n     *  @param {number} TOLERANCE\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    removeZerosEquals(TOLERANCE = 1e-15) {\n        const c = this.coefs;\n        const err = 10 * TOLERANCE * Math.abs(\n            c.reduce((pv, cv) => {\n                return Math.abs(cv) > Math.abs(pv) ? cv : pv;\n            })\n        );\n\n        for (let i = 0; i < c.length - 1; i++) {\n            if (Math.abs(c[i]) < err) {\n                c[i] = 0;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     *  Scales polynomial so that leading coefficient becomes 1.\n     *\n     *  @deprecated To be replaced by getMonic\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    monicEquals() {\n        const c = this.coefs;\n\n        if (c[c.length - 1] !== 1) {\n            this.divideEqualsScalar(c[c.length - 1]);\n        }\n\n        return this;\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const coefs = [];\n        const signs = [];\n\n        for (let i = this.coefs.length - 1; i >= 0; i--) {\n            let value = Math.round(this.coefs[i] * 1000) / 1000;\n\n            if (value !== 0) {\n                const signString = (value < 0) ? \" - \" : \" + \";\n\n                value = Math.abs(value);\n\n                if (i > 0) {\n                    if (value === 1) {\n                        value = this._variable;\n                    }\n                    else {\n                        value += this._variable;\n                    }\n                }\n\n                if (i > 1) {\n                    value += \"^\" + i;\n                }\n\n                signs.push(signString);\n                coefs.push(value);\n            }\n        }\n\n        signs[0] = (signs[0] === \" + \") ? \"\" : \"-\";\n\n        let result = \"\";\n\n        for (let i = 0; i < coefs.length; i++) {\n            result += signs[i] + coefs[i];\n        }\n\n        return result;\n    }\n\n    /**\n     *  bisection\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} [TOLERANCE]\n     *  @param {number} [ACCURACY]\n     *  @returns {number}\n     */\n    bisection(min, max, TOLERANCE = 1e-6, ACCURACY = 15) {\n        let minValue = this.eval(min);\n        let maxValue = this.eval(max);\n        let result;\n\n        if (Math.abs(minValue) <= TOLERANCE) {\n            result = min;\n        }\n        else if (Math.abs(maxValue) <= TOLERANCE) {\n            result = max;\n        }\n        else if (minValue * maxValue <= 0) {\n            const tmp1 = Math.log(max - min);\n            const tmp2 = Math.LN10 * ACCURACY;\n            const maxIterations = Math.ceil((tmp1 + tmp2) / Math.LN2);\n\n            for (let i = 0; i < maxIterations; i++) {\n                result = 0.5 * (min + max);\n                const value = this.eval(result);\n\n                if (Math.abs(value) <= TOLERANCE) {\n                    break;\n                }\n\n                if (value * minValue < 0) {\n                    max = result;\n                    maxValue = value;\n                }\n                else {\n                    min = result;\n                    minValue = value;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 137\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @param {number} n\n     *  @returns {number}\n     */\n    trapezoid(min, max, n) {\n        if (isNaN(min) || isNaN(max) || isNaN(n)) {\n            throw new TypeError(\"Parameters must be numbers\");\n        }\n\n        const range = max - min;\n\n        if (n === 1) {\n            const minValue = this.eval(min);\n            const maxValue = this.eval(max);\n\n            this._s = 0.5 * range * (minValue + maxValue);\n        }\n        else {\n            const iter = 1 << (n - 2);\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 0; i < iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            this._s = 0.5 * (this._s + range * sum / iter);\n        }\n\n        if (isNaN(this._s)) {\n            throw new TypeError(\"this._s is NaN\");\n        }\n\n        return this._s;\n    }\n\n    /**\n     *  Based on trapzd in \"Numerical Recipes in C, 2nd Edition\", page 139\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    simpson(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new TypeError(\"Parameters must be numbers\");\n        }\n\n        const range = max - min;\n        let st = 0.5 * range * (this.eval(min) + this.eval(max));\n        let t = st;\n        let s = 4.0 * st / 3.0;\n        let os = s;\n        let ost = st;\n        const TOLERANCE = 1e-7;\n\n        let iter = 1;\n\n        for (let n = 2; n <= 20; n++) {\n            const delta = range / iter;\n            let x = min + 0.5 * delta;\n            let sum = 0;\n\n            for (let i = 1; i <= iter; i++) {\n                sum += this.eval(x);\n                x += delta;\n            }\n\n            t = 0.5 * (t + range * sum / iter);\n            st = t;\n            s = (4.0 * st - ost) / 3.0;\n\n            if (Math.abs(s - os) < TOLERANCE * Math.abs(os)) {\n                break;\n            }\n\n            os = s;\n            ost = st;\n            iter <<= 1;\n        }\n\n        return s;\n    }\n\n    /**\n     *  romberg\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {number}\n     */\n    romberg(min, max) {\n        if (isNaN(min) || isNaN(max)) {\n            throw new TypeError(\"Parameters must be numbers\");\n        }\n\n        const MAX = 20;\n        const K = 3;\n        const TOLERANCE = 1e-6;\n        const s = new Array(MAX + 1);\n        const h = new Array(MAX + 1);\n        let result = {y: 0, dy: 0};\n\n        h[0] = 1.0;\n\n        for (let j = 1; j <= MAX; j++) {\n            s[j - 1] = this.trapezoid(min, max, j);\n\n            if (j >= K) {\n                result = Polynomial.interpolate(h, s, K, j - K, 0.0);\n                if (Math.abs(result.dy) <= TOLERANCE * result.y) {\n                    break;\n                }\n            }\n\n            s[j] = s[j - 1];\n            h[j] = 0.25 * h[j - 1];\n        }\n\n        return result.y;\n    }\n\n    /**\n     *  Estimate what is the maximum polynomial evaluation error value under which polynomial evaluation could be in fact 0.\n     *\n     *  @param {number} maxAbsX\n     *  @returns {number}\n     */\n    zeroErrorEstimate(maxAbsX) {\n        const poly = this;\n        const ERRF = 1e-15;\n\n        if (typeof maxAbsX === \"undefined\") {\n            const rb = poly.bounds();\n\n            maxAbsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n        }\n\n        if (maxAbsX < 0.001) {\n            return 2 * Math.abs(poly.eval(ERRF));\n        }\n\n        const n = poly.coefs.length - 1;\n        const an = poly.coefs[n];\n\n        return 10 * ERRF * poly.coefs.reduce((m, v, i) => {\n            const nm = v / an * Math.pow(maxAbsX, i);\n            return nm > m ? nm : m;\n        }, 0);\n    }\n\n    /**\n     *  Calculates upper Real roots bounds. <br/>\n     *  Real roots are in interval [negX, posX]. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    boundsUpperRealFujiwara() {\n        let a = this.coefs;\n        const n = a.length - 1;\n        const an = a[n];\n\n        if (an !== 1) {\n            a = this.coefs.map(v => v / an);\n        }\n\n        const b = a.map((v, i) => {\n            return (i < n)\n                ? Math.pow(Math.abs((i === 0) ? v / 2 : v), 1 / (n - i))\n                : v;\n        });\n\n        let coefSelectionFunc;\n        const find2Max = function(acc, bi, i) {\n            if (coefSelectionFunc(i)) {\n                if (acc.max < bi) {\n                    acc.nearmax = acc.max;\n                    acc.max = bi;\n                }\n                else if (acc.nearmax < bi) {\n                    acc.nearmax = bi;\n                }\n            }\n            return acc;\n        };\n\n        coefSelectionFunc = function(i) {\n            return i < n && a[i] < 0;\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_pos = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        coefSelectionFunc = function(i) {\n            return i < n && ((n % 2 === i % 2) ? a[i] < 0 : a[i] > 0);\n        };\n\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        const max_nearmax_neg = b.reduce(find2Max, {max: 0, nearmax: 0});\n\n        return {\n            negX: -2 * max_nearmax_neg.max,\n            posX: 2 * max_nearmax_pos.max\n        };\n    }\n\n    /**\n     *  Calculates lower Real roots bounds. <br/>\n     *  There are no Real roots in interval <negX, posX>. Determined by Fujiwara method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ negX: number, posX: number }}\n     */\n    boundsLowerRealFujiwara() {\n        const poly = new Polynomial();\n\n        poly.coefs = this.coefs.slice().reverse();\n\n        const res = poly.boundsUpperRealFujiwara();\n\n        res.negX = 1 / res.negX;\n        res.posX = 1 / res.posX;\n\n        return res;\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds. <br/>\n     *  Real roots are in interval [minX, maxX]. Combines Fujiwara lower and upper bounds to get minimal interval.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n    */\n    bounds() {\n        const urb = this.boundsUpperRealFujiwara();\n        const rb = {minX: urb.negX, maxX: urb.posX};\n\n        if (urb.negX === 0 && urb.posX === 0) {\n            return rb;\n        }\n\n        if (urb.negX === 0) {\n            rb.minX = this.boundsLowerRealFujiwara().posX;\n        }\n        else if (urb.posX === 0) {\n            rb.maxX = this.boundsLowerRealFujiwara().negX;\n        }\n\n        if (rb.minX > rb.maxX) {\n            rb.minX = rb.maxX = 0;\n        }\n\n        return rb;\n        // TODO: if sure that there are no complex roots\n        // (maybe by using Sturm's theorem) use:\n        // return this.boundsRealLaguerre();\n    }\n\n    /**\n     *  Calculates absolute upper roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &lt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {number}\n     */\n    boundUpperAbsRouche() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== n) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return 1 + max / Math.abs(a[n]);\n    }\n\n    /**\n     *  Calculates absolute lower roots bound. <br/>\n     *  All (Complex and Real) roots magnitudes are &gt;= result. Determined by Rouche method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {number}\n     */\n    boundLowerAbsRouche() {\n        const a = this.coefs;\n        const max = a.reduce((prev, curr, i) => {\n            if (i !== 0) {\n                curr = Math.abs(curr);\n                return (prev < curr) ? curr : prev;\n            }\n            return prev;\n        }, 0);\n\n        return Math.abs(a[0]) / (Math.abs(a[0]) + max);\n    }\n\n    /**\n     *  Calculates left and right Real roots bounds.<br/>\n     *  WORKS ONLY if all polynomial roots are Real.\n     *  Real roots are in interval [minX, maxX]. Determined by Laguerre method.\n     *  @see {@link http://en.wikipedia.org/wiki/Properties_of_polynomial_roots}\n     *\n     *  @returns {{ minX: number, maxX: number }}\n     */\n    boundsRealLaguerre() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const p1 = -a[n - 1] / (n * a[n]);\n        const undersqrt = a[n - 1] * a[n - 1] - 2 * n / (n - 1) * a[n] * a[n - 2];\n        let p2 = (n - 1) / (n * a[n]) * Math.sqrt(undersqrt);\n\n        if (p2 < 0) {\n            p2 = -p2;\n        }\n\n        return {\n            minX: p1 - p2,\n            maxX: p1 + p2\n        };\n    }\n\n    /**\n     *  Root count by Descartes rule of signs. <br/>\n     *  Returns maximum number of positive and negative real roots and minimum number of complex roots.\n     *  @see {@link http://en.wikipedia.org/wiki/Descartes%27_rule_of_signs}\n     *\n     *  @returns {{maxRealPos: number, maxRealNeg: number, minComplex: number}}\n     */\n    countRootsDescartes() {\n        const a = this.coefs;\n        const n = a.length - 1;\n        const accum = a.reduce((acc, ai, i) => {\n            if (acc.prev_a !== 0 && ai !== 0) {\n                if ((acc.prev_a < 0) === (ai > 0)) {\n                    acc.pos++;\n                }\n                if (((i % 2 === 0) !== (acc.prev_a < 0)) === ((i % 2 === 1) !== (ai > 0))) {\n                    acc.neg++;\n                }\n            }\n            acc.prev_a = ai;\n            return acc;\n        }, {pos: 0, neg: 0, prev_a: 0});\n\n        return {\n            maxRealPos: accum.pos,\n            maxRealNeg: accum.neg,\n            minComplex: n - (accum.pos + accum.neg)\n        };\n    }\n\n    // getters and setters\n\n    /**\n     *  get degree\n     *\n     *  @returns {number}\n     */\n    getDegree() {\n        return this.coefs.length - 1;\n    }\n\n    /**\n     *  getDerivative\n     *\n     *  @returns {module:kld-polynomial.Polynomial}\n     */\n    getDerivative() {\n        const derivative = new Polynomial();\n\n        for (let i = 1; i < this.coefs.length; i++) {\n            derivative.coefs.push(i * this.coefs[i]);\n        }\n\n        return derivative;\n    }\n\n    /**\n     *  getRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getRoots() {\n        let result;\n\n        this.simplifyEquals();\n\n        switch (this.getDegree()) {\n            case 0: result = []; break;\n            case 1: result = this.getLinearRoot(); break;\n            case 2: result = this.getQuadraticRoots(); break;\n            case 3: result = this.getCubicRoots(); break;\n            case 4: result = this.getQuarticRoots(); break;\n            default:\n                result = [];\n        }\n\n        return result;\n    }\n\n    /**\n     *  getRootsInInterval\n     *\n     *  @param {number} min\n     *  @param {number} max\n     *  @returns {Array<number>}\n     */\n    getRootsInInterval(min, max) {\n        const roots = [];\n\n        /**\n         *  @param {number} value\n         */\n        function push(value) {\n            if (typeof value === \"number\") {\n                roots.push(value);\n            }\n        }\n\n        if (this.getDegree() === 0) {\n            throw new RangeError(\"Unexpected empty polynomial\");\n        }\n        else if (this.getDegree() === 1) {\n            push(this.bisection(min, max));\n        }\n        else {\n            // get roots of derivative\n            const deriv = this.getDerivative();\n            const droots = deriv.getRootsInInterval(min, max);\n\n            if (droots.length > 0) {\n                // find root on [min, droots[0]]\n                push(this.bisection(min, droots[0]));\n\n                // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2\n                for (let i = 0; i <= droots.length - 2; i++) {\n                    push(this.bisection(droots[i], droots[i + 1]));\n                }\n\n                // find root on [droots[count-1],xmax]\n                push(this.bisection(droots[droots.length - 1], max));\n            }\n            else {\n                // polynomial is monotone on [min,max], has at most one root\n                push(this.bisection(min, max));\n            }\n        }\n\n        return roots;\n    }\n\n    /**\n     *  getLinearRoot\n     *\n     *  @returns {number}\n     */\n    getLinearRoot() {\n        const result = [];\n        const a = this.coefs[1];\n\n        if (a !== 0) {\n            result.push(-this.coefs[0] / a);\n        }\n\n        return result;\n    }\n\n    /**\n     *  getQuadraticRoots\n     *\n     *  @returns {Array<number>}\n     */\n    getQuadraticRoots() {\n        const results = [];\n\n        if (this.getDegree() === 2) {\n            const a = this.coefs[2];\n            const b = this.coefs[1] / a;\n            const c = this.coefs[0] / a;\n            const d = b * b - 4 * c;\n\n            if (d > 0) {\n                const e = Math.sqrt(d);\n\n                results.push(0.5 * (-b + e));\n                results.push(0.5 * (-b - e));\n            }\n            else if (d === 0) {\n                // really two roots with same value, but we only return one\n                results.push(0.5 * -b);\n            }\n            // else imaginary results\n        }\n\n        return results;\n    }\n\n    /**\n     *  getCubicRoots\n     *\n     *  This code is based on MgcPolynomial.cpp written by David Eberly.  His\n     *  code along with many other excellent examples are avaiable at his site:\n     *  http://www.geometrictools.com\n     *\n     *  @returns {Array<number>}\n     */\n    getCubicRoots() {\n        const results = [];\n\n        if (this.getDegree() === 3) {\n            const c3 = this.coefs[3];\n            const c2 = this.coefs[2] / c3;\n            const c1 = this.coefs[1] / c3;\n            const c0 = this.coefs[0] / c3;\n\n            const a = (3 * c1 - c2 * c2) / 3;\n            const b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;\n            const offset = c2 / 3;\n            let discrim = b * b / 4 + a * a * a / 27;\n            const halfB = b / 2;\n\n            const ZEROepsilon = this.zeroErrorEstimate();\n\n            if (Math.abs(discrim) <= ZEROepsilon) {\n                discrim = 0;\n            }\n\n            if (discrim > 0) {\n                const e = Math.sqrt(discrim);\n                let root; // eslint-disable-line no-shadow\n\n                let tmp = -halfB + e;\n\n                if (tmp >= 0) {\n                    root = Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root = -Math.pow(-tmp, 1 / 3);\n                }\n\n                tmp = -halfB - e;\n\n                if (tmp >= 0) {\n                    root += Math.pow(tmp, 1 / 3);\n                }\n                else {\n                    root -= Math.pow(-tmp, 1 / 3);\n                }\n\n                results.push(root - offset);\n            }\n            else if (discrim < 0) {\n                const distance = Math.sqrt(-a / 3);\n                const angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;\n                const cos = Math.cos(angle);\n                const sin = Math.sin(angle);\n                const sqrt3 = Math.sqrt(3);\n\n                results.push(2 * distance * cos - offset);\n                results.push(-distance * (cos + sqrt3 * sin) - offset);\n                results.push(-distance * (cos - sqrt3 * sin) - offset);\n            }\n            else {\n                let tmp;\n\n                if (halfB >= 0) {\n                    tmp = -Math.pow(halfB, 1 / 3);\n                }\n                else {\n                    tmp = Math.pow(-halfB, 1 / 3);\n                }\n\n                results.push(2 * tmp - offset);\n                // really should return next root twice, but we return only one\n                results.push(-tmp - offset);\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     *  Calculates roots of quartic polynomial. <br/>\n     *  First, derivative roots are found, then used to split quartic polynomial\n     *  into segments, each containing one root of quartic polynomial.\n     *  Segments are then passed to newton's method to find roots.\n     *\n     *  @returns {Array<number>} roots\n     */\n    getQuarticRoots() {\n        let results = [];\n        const n = this.getDegree();\n\n        if (n === 4) {\n            const poly = new Polynomial();\n\n            poly.coefs = this.coefs.slice();\n            poly.divideEqualsScalar(poly.coefs[n]);\n\n            const ERRF = 1e-15;\n\n            if (Math.abs(poly.coefs[0]) < 10 * ERRF * Math.abs(poly.coefs[3])) {\n                poly.coefs[0] = 0;\n            }\n\n            const poly_d = poly.getDerivative();\n            const derrt = poly_d.getRoots().sort((a, b) => a - b);\n            const dery = [];\n            const nr = derrt.length - 1;\n            const rb = this.bounds();\n\n            const maxabsX = Math.max(Math.abs(rb.minX), Math.abs(rb.maxX));\n            const ZEROepsilon = this.zeroErrorEstimate(maxabsX);\n\n            for (let i = 0; i <= nr; i++) {\n                dery.push(poly.eval(derrt[i]));\n            }\n\n            for (let i = 0; i <= nr; i++) {\n                if (Math.abs(dery[i]) < ZEROepsilon) {\n                    dery[i] = 0;\n                }\n            }\n\n            let i = 0;\n            const dx = Math.max(0.1 * (rb.maxX - rb.minX) / n, ERRF);\n            const guesses = [];\n            const minmax = [];\n\n            if (nr > -1) {\n                if (dery[0] !== 0) {\n                    if (sign(dery[0]) !== sign(poly.eval(derrt[0] - dx) - dery[0])) {\n                        guesses.push(derrt[0] - dx);\n                        minmax.push([rb.minX, derrt[0]]);\n                    }\n                }\n                else {\n                    results.push(derrt[0], derrt[0]);\n                    i++;\n                }\n\n                for (; i < nr; i++) {\n                    if (dery[i + 1] === 0) {\n                        results.push(derrt[i + 1], derrt[i + 1]);\n                        i++;\n                    }\n                    else if (sign(dery[i]) !== sign(dery[i + 1])) {\n                        guesses.push((derrt[i] + derrt[i + 1]) / 2);\n                        minmax.push([derrt[i], derrt[i + 1]]);\n                    }\n                }\n                if (dery[nr] !== 0 && sign(dery[nr]) !== sign(poly.eval(derrt[nr] + dx) - dery[nr])) {\n                    guesses.push(derrt[nr] + dx);\n                    minmax.push([derrt[nr], rb.maxX]);\n                }\n            }\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const f = function(x) {\n                return poly.eval(x);\n            };\n\n            /**\n             *  @param {number} x\n             *  @returns {number}\n             */\n            const df = function(x) {\n                return poly_d.eval(x);\n            };\n\n            if (guesses.length > 0) {\n                for (i = 0; i < guesses.length; i++) {\n                    guesses[i] = Polynomial.newtonSecantBisection(guesses[i], f, df, 32, minmax[i][0], minmax[i][1]);\n                }\n            }\n\n            results = results.concat(guesses);\n        }\n\n        return results;\n    }\n}\n\nexport default Polynomial;\n","/**\n *  SqrtPolynomial.js\n *\n *  @module SqrtPolynomial\n *  @copyright 2002-2019 Kevin Lindsey\n */\n\nimport Polynomial from \"./Polynomial.js\";\n\n/**\n *  SqrtPolynomial\n *\n *  @deprecated\n *  @memberof module:kld-polynomial\n */\nclass SqrtPolynomial extends Polynomial {\n    /**\n     *  eval\n     *\n     *  @param {number} x\n     *  @returns {number}\n     */\n    eval(x) {\n        const TOLERANCE = 1e-7;\n\n        let result = super.eval(x);\n\n        // NOTE: May need to change the following.  I added these to capture\n        // some really small negative values that were being generated by one\n        // of my Bezier arcLength functions\n        if (Math.abs(result) < TOLERANCE) {\n            result = 0;\n        }\n\n        if (result < 0) {\n            throw new RangeError(\"Cannot take square root of negative number\");\n        }\n\n        return Math.sqrt(result);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        const result = super.toString();\n\n        return \"sqrt(\" + result + \")\";\n    }\n}\n\nexport default SqrtPolynomial;\n","/**\n *  Point2D.js\n *  @module Point2D\n *  @copyright 2001-2019 Kevin Lindsey\n */\n\n/**\n *  Point2D\n *\n *  @memberof module:kld-affine\n */\nclass Point2D {\n    /**\n     *  Point2D\n     *\n     *  @param {number} x\n     *  @param {number} y\n     *  @returns {module:kld-affine.Point2D}\n     */\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     *  clone\n     *\n     *  @returns {module:kld-affine.Point2D}\n     */\n    clone() {\n        return new this.constructor(this.x, this.y);\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {module:kld-affine.Point2D}\n     */\n    add(that) {\n        return new this.constructor(this.x + that.x, this.y + that.y);\n    }\n\n    /**\n     *  subtract\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {module:kld-affine.Point2D}\n     */\n    subtract(that) {\n        return new this.constructor(this.x - that.x, this.y - that.y);\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Point2D}\n     */\n    multiply(scalar) {\n        return new this.constructor(this.x * scalar, this.y * scalar);\n    }\n\n    /**\n     *  divide\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Point2D}\n     */\n    divide(scalar) {\n        return new this.constructor(this.x / scalar, this.y / scalar);\n    }\n\n    /**\n     *  equals\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {boolean}\n     */\n    equals(that) {\n        return (this.x === that.x && this.y === that.y);\n    }\n\n    /**\n     *  precisionEquals\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @param {number} precision\n     *  @returns {boolean}\n     */\n    precisionEquals(that, precision) {\n        return (\n            Math.abs(this.x - that.x) < precision &&\n            Math.abs(this.y - that.y) < precision\n        );\n    }\n\n    // utility methods\n\n    /**\n     *  lerp\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @param {number} t\n     *  @returns {module:kld-affine.Point2D}\n     */\n    lerp(that, t) {\n        const omt = 1.0 - t;\n\n        return new this.constructor(\n            this.x * omt + that.x * t,\n            this.y * omt + that.y * t\n        );\n    }\n\n    /**\n     *  distanceFrom\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {number}\n     */\n    distanceFrom(that) {\n        const dx = this.x - that.x;\n        const dy = this.y - that.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     *  min\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {number}\n     */\n    min(that) {\n        return new this.constructor(\n            Math.min(this.x, that.x),\n            Math.min(this.y, that.y)\n        );\n    }\n\n    /**\n     *  max\n     *\n     *  @param {module:kld-affine.Point2D} that\n     *  @returns {number}\n     */\n    max(that) {\n        return new this.constructor(\n            Math.max(this.x, that.x),\n            Math.max(this.y, that.y)\n        );\n    }\n\n    /**\n     *  transform\n     *\n     *  @param {module:kld-affine.Matrix2D} matrix\n     *  @returns {module:kld-affine.Point2D}\n     */\n    transform(matrix) {\n        return new this.constructor(\n            matrix.a * this.x + matrix.c * this.y + matrix.e,\n            matrix.b * this.x + matrix.d * this.y + matrix.f\n        );\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return `point(${this.x},${this.y})`;\n    }\n}\n\nexport default Point2D;\n","/**\n *  Vector2D.js\n *  @module Vector2D\n *  @copyright 2001-2019 Kevin Lindsey\n */\n\n/**\n *  Vector2D\n *\n *  @memberof module:kld-affine\n */\nclass Vector2D {\n    /**\n     *  Vector2D\n     *\n     *  @param {number} x\n     *  @param {number} y\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    constructor(x = 0, y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     *  fromPoints\n     *\n     *  @param {module:kld-affine.Point2D} p1\n     *  @param {module:kld-affine.Point2D} p2\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    static fromPoints(p1, p2) {\n        return new Vector2D(\n            p2.x - p1.x,\n            p2.y - p1.y\n        );\n    }\n\n    /**\n     *  length\n     *\n     *  @returns {number}\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    /**\n     *  magnitude\n     *\n     *  @returns {number}\n     */\n    magnitude() {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    /**\n     *  dot\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    dot(that) {\n        return this.x * that.x + this.y * that.y;\n    }\n\n    /**\n     *  cross\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    cross(that) {\n        return this.x * that.y - this.y * that.x;\n    }\n\n    /**\n     *  determinant\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    determinant(that) {\n        return this.x * that.y - this.y * that.x;\n    }\n\n    /**\n     *  unit\n     *\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    unit() {\n        return this.divide(this.length());\n    }\n\n    /**\n     *  add\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    add(that) {\n        return new this.constructor(this.x + that.x, this.y + that.y);\n    }\n\n    /**\n     *  subtract\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    subtract(that) {\n        return new this.constructor(this.x - that.x, this.y - that.y);\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    multiply(scalar) {\n        return new this.constructor(this.x * scalar, this.y * scalar);\n    }\n\n    /**\n     *  divide\n     *\n     *  @param {number} scalar\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    divide(scalar) {\n        return new this.constructor(this.x / scalar, this.y / scalar);\n    }\n\n    /**\n     *  angleBetween\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {number}\n     */\n    angleBetween(that) {\n        let cos = this.dot(that) / (this.length() * that.length());\n        cos = Math.max(-1, Math.min(cos, 1));\n        const radians = Math.acos(cos);\n\n        return (this.cross(that) < 0.0) ? -radians : radians;\n    }\n\n    /**\n     *  Find a vector is that is perpendicular to this vector\n     *\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    perp() {\n        return new this.constructor(-this.y, this.x);\n    }\n\n    /**\n     *  Find the component of the specified vector that is perpendicular to\n     *  this vector\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    perpendicular(that) {\n        return this.subtract(this.project(that));\n    }\n\n    /**\n     *  project\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    project(that) {\n        const percent = this.dot(that) / that.dot(that);\n\n        return that.multiply(percent);\n    }\n\n    /**\n     *  transform\n     *\n     *  @param {module:kld-affine.Matrix2D} matrix\n     *  @returns {module:kld-affine.Vector2D}\n     */\n    transform(matrix) {\n        return new this.constructor(\n            matrix.a * this.x + matrix.c * this.y,\n            matrix.b * this.x + matrix.d * this.y\n        );\n    }\n\n    /**\n     *  equals\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @returns {boolean}\n     */\n    equals(that) {\n        return (\n            this.x === that.x &&\n            this.y === that.y\n        );\n    }\n\n    /**\n     *  precisionEquals\n     *\n     *  @param {module:kld-affine.Vector2D} that\n     *  @param {number} precision\n     *  @returns {boolean}\n     */\n    precisionEquals(that, precision) {\n        return (\n            Math.abs(this.x - that.x) < precision &&\n            Math.abs(this.y - that.y) < precision\n        );\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return `vector(${this.x},${this.y})`;\n    }\n}\n\nexport default Vector2D;\n","/**\n *  Matrix2D.js\n *  @module Matrix2D\n *  @copyright 2001-2019 Kevin Lindsey\n */\n\n/**\n *  Matrix2D\n *\n *  @memberof module:kld-affine\n */\nclass Matrix2D {\n    /**\n     *  A 2D Matrix of the form:<br>\n     *  [a c e]<br>\n     *  [b d f]<br>\n     *  [0 0 1]<br>\n     *\n     *  @param {number} a\n     *  @param {number} b\n     *  @param {number} c\n     *  @param {number} d\n     *  @param {number} e\n     *  @param {number} f\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, e = 0, f = 0) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.e = e;\n        this.f = f;\n    }\n\n    /**\n     *  translation\n     *\n     *  @param {number} tx\n     *  @param {number} ty\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static translation(tx, ty) {\n        return new Matrix2D(1, 0, 0, 1, tx, ty);\n    }\n\n    /**\n     *  scaling\n     *\n     *  @param {number} scale\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static scaling(scale) {\n        return new Matrix2D(scale, 0, 0, scale, 0, 0);\n    }\n\n    /**\n     *  scalingAt\n     *\n     *  @param {number} scale\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static scalingAt(scale, center) {\n        return new Matrix2D(\n            scale,\n            0,\n            0,\n            scale,\n            center.x - center.x * scale,\n            center.y - center.y * scale\n        );\n    }\n\n    /**\n     *  nonUniformScaling\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static nonUniformScaling(scaleX, scaleY) {\n        return new Matrix2D(scaleX, 0, 0, scaleY, 0, 0);\n    }\n\n    /**\n     *  nonUniformScalingAt\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static nonUniformScalingAt(scaleX, scaleY, center) {\n        return new Matrix2D(\n            scaleX,\n            0,\n            0,\n            scaleY,\n            center.x - center.x * scaleX,\n            center.y - center.y * scaleY\n        );\n    }\n\n    /**\n     *  rotation\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static rotation(radians) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n\n        return new Matrix2D(c, s, -s, c, 0, 0);\n    }\n\n    /**\n     *  rotationAt\n     *\n     *  @param {number} radians\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static rotationAt(radians, center) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n\n        return new Matrix2D(\n            c,\n            s,\n            -s,\n            c,\n            center.x - center.x * c + center.y * s,\n            center.y - center.y * c - center.x * s\n        );\n    }\n\n    /**\n     *  rotationFromVector\n     *\n     *  @param {module:kld-affine.Vector2D} vector\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static rotationFromVector(vector) {\n        const unit = vector.unit();\n        const c = unit.x; // cos\n        const s = unit.y; // sin\n\n        return new Matrix2D(c, s, -s, c, 0, 0);\n    }\n\n    /**\n     *  xFlip\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static xFlip() {\n        return new Matrix2D(-1, 0, 0, 1, 0, 0);\n    }\n\n    /**\n     *  yFlip\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static yFlip() {\n        return new Matrix2D(1, 0, 0, -1, 0, 0);\n    }\n\n    /**\n     *  xSkew\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static xSkew(radians) {\n        const t = Math.tan(radians);\n\n        return new Matrix2D(1, 0, t, 1, 0, 0);\n    }\n\n    /**\n     *  ySkew\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    static ySkew(radians) {\n        const t = Math.tan(radians);\n\n        return new Matrix2D(1, t, 0, 1, 0, 0);\n    }\n\n    /**\n     *  multiply\n     *\n     *  @param {module:kld-affine.Matrix2D} that\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    multiply(that) {\n        if (this.isIdentity()) {\n            return that;\n        }\n\n        if (that.isIdentity()) {\n            return this;\n        }\n\n        return new this.constructor(\n            this.a * that.a + this.c * that.b,\n            this.b * that.a + this.d * that.b,\n            this.a * that.c + this.c * that.d,\n            this.b * that.c + this.d * that.d,\n            this.a * that.e + this.c * that.f + this.e,\n            this.b * that.e + this.d * that.f + this.f\n        );\n    }\n\n    /**\n     *  inverse\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    inverse() {\n        if (this.isIdentity()) {\n            return this;\n        }\n\n        const det1 = this.a * this.d - this.b * this.c;\n\n        if (det1 === 0.0) {\n            throw new Error(\"Matrix is not invertible\");\n        }\n\n        const idet = 1.0 / det1;\n        const det2 = this.f * this.c - this.e * this.d;\n        const det3 = this.e * this.b - this.f * this.a;\n\n        return new this.constructor(\n            this.d * idet,\n            -this.b * idet,\n            -this.c * idet,\n            this.a * idet,\n            det2 * idet,\n            det3 * idet\n        );\n    }\n\n    /**\n     *  translate\n     *\n     *  @param {number} tx\n     *  @param {number} ty\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    translate(tx, ty) {\n        return new this.constructor(\n            this.a,\n            this.b,\n            this.c,\n            this.d,\n            this.a * tx + this.c * ty + this.e,\n            this.b * tx + this.d * ty + this.f\n        );\n    }\n\n    /**\n     *  scale\n     *\n     *  @param {number} scale\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scale(scale) {\n        return new this.constructor(\n            this.a * scale,\n            this.b * scale,\n            this.c * scale,\n            this.d * scale,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  scaleAt\n     *\n     *  @param {number} scale\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scaleAt(scale, center) {\n        const dx = center.x - scale * center.x;\n        const dy = center.y - scale * center.y;\n\n        return new this.constructor(\n            this.a * scale,\n            this.b * scale,\n            this.c * scale,\n            this.d * scale,\n            this.a * dx + this.c * dy + this.e,\n            this.b * dx + this.d * dy + this.f\n        );\n    }\n\n    /**\n     *  scaleNonUniform\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scaleNonUniform(scaleX, scaleY) {\n        return new this.constructor(\n            this.a * scaleX,\n            this.b * scaleX,\n            this.c * scaleY,\n            this.d * scaleY,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  scaleNonUniformAt\n     *\n     *  @param {number} scaleX\n     *  @param {number} scaleY\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    scaleNonUniformAt(scaleX, scaleY, center) {\n        const dx = center.x - scaleX * center.x;\n        const dy = center.y - scaleY * center.y;\n\n        return new this.constructor(\n            this.a * scaleX,\n            this.b * scaleX,\n            this.c * scaleY,\n            this.d * scaleY,\n            this.a * dx + this.c * dy + this.e,\n            this.b * dx + this.d * dy + this.f\n        );\n    }\n\n    /**\n     *  rotate\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    rotate(radians) {\n        const c = Math.cos(radians);\n        const s = Math.sin(radians);\n\n        return new this.constructor(\n            this.a * c + this.c * s,\n            this.b * c + this.d * s,\n            this.a * -s + this.c * c,\n            this.b * -s + this.d * c,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  rotateAt\n     *\n     *  @param {number} radians\n     *  @param {module:kld-affine.Point2D} center\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    rotateAt(radians, center) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        const cx = center.x;\n        const cy = center.y;\n\n        const a = this.a * cos + this.c * sin;\n        const b = this.b * cos + this.d * sin;\n        const c = this.c * cos - this.a * sin;\n        const d = this.d * cos - this.b * sin;\n\n        return new this.constructor(\n            a,\n            b,\n            c,\n            d,\n            (this.a - a) * cx + (this.c - c) * cy + this.e,\n            (this.b - b) * cx + (this.d - d) * cy + this.f\n        );\n    }\n\n    /**\n     *  rotateFromVector\n     *\n     *  @param {module:kld-affine.Vector2D} vector\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    rotateFromVector(vector) {\n        const unit = vector.unit();\n        const c = unit.x; // cos\n        const s = unit.y; // sin\n\n        return new this.constructor(\n            this.a * c + this.c * s,\n            this.b * c + this.d * s,\n            this.a * -s + this.c * c,\n            this.b * -s + this.d * c,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  flipX\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    flipX() {\n        return new this.constructor(\n            -this.a,\n            -this.b,\n            this.c,\n            this.d,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  flipY\n     *\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    flipY() {\n        return new this.constructor(\n            this.a,\n            this.b,\n            -this.c,\n            -this.d,\n            this.e,\n            this.f\n        );\n    }\n\n    /**\n     *  skewX\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    skewX(radians) {\n        const t = Math.tan(radians);\n\n        return new this.constructor(\n            this.a,\n            this.b,\n            this.c + this.a * t,\n            this.d + this.b * t,\n            this.e,\n            this.f\n        );\n    }\n\n    // TODO: skewXAt\n\n    /**\n     *  skewY\n     *\n     *  @param {number} radians\n     *  @returns {module:kld-affine.Matrix2D}\n     */\n    skewY(radians) {\n        const t = Math.tan(radians);\n\n        return new this.constructor(\n            this.a + this.c * t,\n            this.b + this.d * t,\n            this.c,\n            this.d,\n            this.e,\n            this.f\n        );\n    }\n\n    // TODO: skewYAt\n\n    /**\n     *  isIdentity\n     *\n     *  @returns {boolean}\n     */\n    isIdentity() {\n        return (\n            this.a === 1.0 &&\n            this.b === 0.0 &&\n            this.c === 0.0 &&\n            this.d === 1.0 &&\n            this.e === 0.0 &&\n            this.f === 0.0\n        );\n    }\n\n    /**\n     *  isInvertible\n     *\n     *  @returns {boolean}\n     */\n    isInvertible() {\n        return this.a * this.d - this.b * this.c !== 0.0;\n    }\n\n    /**\n     *  getScale\n     *\n     *  @returns {{ scaleX: number, scaleY: number }}\n     */\n    getScale() {\n        return {\n            scaleX: Math.sqrt(this.a * this.a + this.c * this.c),\n            scaleY: Math.sqrt(this.b * this.b + this.d * this.d)\n        };\n    }\n\n    /**\n     *  Calculates matrix Singular Value Decomposition\n     *\n     *  The resulting matrices  translation, rotation, scale, and rotation0  return\n     *  this matrix when they are multiplied together in the listed order\n     *\n     *  @see Jim Blinn's article {@link http://dx.doi.org/10.1109/38.486688}\n     *  @see {@link http://math.stackexchange.com/questions/861674/decompose-a-2d-arbitrary-transform-into-only-scaling-and-rotation}\n     *\n     *  @returns {{\n     *    translation: module:kld-affine.Matrix2D,\n     *    rotation: module:kld-affine.Matrix2D,\n     *    scale: module:kld-affine.Matrix2D,\n     *    rotation0: module:kld-affine.Matrix2D\n     *  }}\n     */\n    getDecomposition() {\n        const E = (this.a + this.d) * 0.5;\n        const F = (this.a - this.d) * 0.5;\n        const G = (this.b + this.c) * 0.5;\n        const H = (this.b - this.c) * 0.5;\n\n        const Q = Math.sqrt(E * E + H * H);\n        const R = Math.sqrt(F * F + G * G);\n        const scaleX = Q + R;\n        const scaleY = Q - R;\n\n        const a1 = Math.atan2(G, F);\n        const a2 = Math.atan2(H, E);\n        const theta = (a2 - a1) * 0.5;\n        const phi = (a2 + a1) * 0.5;\n\n        return {\n            translation: this.constructor.translation(this.e, this.f),\n            rotation: this.constructor.rotation(phi),\n            scale: this.constructor.nonUniformScaling(scaleX, scaleY),\n            rotation0: this.constructor.rotation(theta)\n        };\n    }\n\n    /**\n     *  equals\n     *\n     *  @param {module:kld-affine.Matrix2D} that\n     *  @returns {boolean}\n     */\n    equals(that) {\n        return (\n            this.a === that.a &&\n            this.b === that.b &&\n            this.c === that.c &&\n            this.d === that.d &&\n            this.e === that.e &&\n            this.f === that.f\n        );\n    }\n\n    /**\n     *  precisionEquals\n     *\n     *  @param {module:kld-affine.Matrix2D} that\n     *  @param {number} precision\n     *  @returns {boolean}\n     */\n    precisionEquals(that, precision) {\n        return (\n            Math.abs(this.a - that.a) < precision &&\n            Math.abs(this.b - that.b) < precision &&\n            Math.abs(this.c - that.c) < precision &&\n            Math.abs(this.d - that.d) < precision &&\n            Math.abs(this.e - that.e) < precision &&\n            Math.abs(this.f - that.f) < precision\n        );\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return `matrix(${this.a},${this.b},${this.c},${this.d},${this.e},${this.f})`;\n    }\n}\n\n/**\n *  Identity matrix\n *\n *  @returns {module:kld-affine.Matrix2D}\n */\nMatrix2D.IDENTITY = new Matrix2D();\nMatrix2D.IDENTITY.isIdentity = () => true;\n\n\nexport default Matrix2D;\n","/**\n *  CubicBezier2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module CubicBezier2D\n */\nimport {Polynomial, SqrtPolynomial} from \"kld-polynomial\";\nimport {Matrix2D, Point2D, Vector2D} from \"kld-affine\";\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  CubicBezier2D\n */\nclass CubicBezier2D {\n    /**\n     *  @param {module:kld-affine.Point2D} p1\n     *  @param {module:kld-affine.Point2D} p2\n     *  @param {module:kld-affine.Point2D} p3\n     *  @param {module:kld-affine.Point2D} p4\n     *  @returns {module:kld-contours~CubicBezier2D}\n     */\n    constructor(p1, p2, p3, p4) {\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n        this.p4 = p4;\n    }\n\n    /**\n     *  getPointAtParameter\n     *\n     *  @param {number} t\n     *  @returns {module:kld-affine.Point2D}\n     */\n    getPointAtParameter(t) {\n        // TODO: validate t in [0,1]\n\n        // first round of lerps\n        const p5 = this.p1.lerp(this.p2, t);\n        const p6 = this.p2.lerp(this.p3, t);\n        const p7 = this.p3.lerp(this.p4, t);\n\n        // second round of lerps\n        const p8 = p5.lerp(p6, t);\n        const p9 = p6.lerp(p7, t);\n\n        return p8.lerp(p9, t);\n    }\n\n    /**\n     *  splitAtParameter\n     *\n     *  @param {number} t\n     *  @returns {Array<module:kld-contours~CubicBezier2D>}\n     */\n    splitAtParameter(t) {\n        // first round of lerps\n        const p5 = this.p1.lerp(this.p2, t);\n        const p6 = this.p2.lerp(this.p3, t);\n        const p7 = this.p3.lerp(this.p4, t);\n\n        // second round of lerps\n        const p8 = p5.lerp(p6, t);\n        const p9 = p6.lerp(p7, t);\n\n        // third round of lerps\n        const p10 = p8.lerp(p9, t);\n\n        return [\n            new CubicBezier2D(this.p1, p5, p8, p10),\n            new CubicBezier2D(p10, p9, p7, this.p4)\n        ];\n    }\n\n    /**\n     *  getBernsteinPolynomials\n     *\n     *  @returns {{x: module:kld-polynomial.Polynomial, y: module:kld-polynomial.Polynomial}}\n     */\n    getBernsteinPolynomials() {\n        let a, b, c;\n\n        // Start with Bezier using Bernstein polynomials for weighting functions:\n        //     (1-t^3)P1 + 3t(1-t)^2P2 + 3t^2(1-t)P3 + t^3P4\n        //\n        // Expand and collect terms to form linear combinations of original Bezier\n        // controls.  This ends up with a vector cubic in t:\n        //     (-P1+3P2-3P3+P4)t^3 + (3P1-6P2+3P3)t^2 + (-3P1+3P2)t + P1\n        //             /\\                  /\\                /\\       /\\\n        //             ||                  ||                ||       ||\n        //             c3                  c2                c1       c0\n\n        // Calculate the coefficients\n        a = this.p1.multiply(-1);\n        b = this.p2.multiply(3);\n        c = this.p3.multiply(-3);\n        const c3 = a.add(b.add(c.add(this.p4)));\n\n        a = this.p1.multiply(3);\n        b = this.p2.multiply(-6);\n        c = this.p3.multiply(3);\n        const c2 = a.add(b.add(c));\n\n        a = this.p1.multiply(-3);\n        b = this.p2.multiply(3);\n        const c1 = a.add(b);\n\n        const c0 = this.p1;\n\n        return {\n            x: new Polynomial(c3.x, c2.x, c1.x, c0.x),\n            y: new Polynomial(c3.y, c2.y, c1.y, c0.y)\n        };\n    }\n\n    /**\n     *  getArcLengthPolynomial\n     *\n     *  @returns {module:kld-polynomial.SqrtPolynomial}\n     */\n    getArcLengthPolynomial() {\n        // TODO: use Object.defineProperty\n        // TODO: use results from getBernsteinPolynomials but need getCoeficent in\n        // Polynomial first\n\n        /* eslint-disable-next-line no-prototype-builtins */\n        if (!this.hasOwnProperty(\"arcLengthPolynomial\")) {\n            let a, b, c;\n\n            // convert to Bernstein polynomials\n            a = this.p1.multiply(-1);\n            b = this.p2.multiply(3);\n            c = this.p3.multiply(-3);\n            const c3 = a.add(b.add(c.add(this.p4)));\n\n            a = this.p1.multiply(3);\n            b = this.p2.multiply(-6);\n            c = this.p3.multiply(3);\n            const c2 = a.add(b.add(c));\n\n            a = this.p1.multiply(-3);\n            b = this.p2.multiply(3);\n            const c1 = a.add(b);\n\n            //  ____________\n            //  dx^2 + dy^2\n            //\n            this.arcLengthPolynomial = new SqrtPolynomial(\n                9 * (c3.x * c3.x + c3.y * c3.y),\n                12 * (c2.x * c3.x + c2.y * c3.y),\n                4 * (c2.x * c2.x + c2.y * c2.y) + 6 * (c1.x * c3.x + c1.y * c3.y),\n                4 * (c1.x * c2.x + c1.y * c2.y),\n                c1.x * c1.x + c1.y * c1.y\n            );\n\n            this.arcLength = this.arcLengthPolynomial.romberg(0, 1);\n            // this.arcLength = this.arcLengthPolynomial.simpson(0, 1);\n        }\n\n        return this.arcLengthPolynomial;\n    }\n\n    /**\n     *  getParameterFromArcLength\n     *\n     *  @param {number} arcLength\n     *  @returns {number}\n     */\n    getParameterFromArcLength(arcLength) {\n        // TODO: extract common Bezier code\n\n        // make sure the arc length polynomial and arc length values have been calculated\n        const arcLengthPolynomial = this.getArcLengthPolynomial();\n        let result;\n\n        if (arcLength <= 0) {\n            result = 0;\n        }\n        else if (arcLength >= this.arcLength) {\n            result = 1;\n        }\n        else {\n            const TOLERANCE = 1e-9;\n            const MAXITERS = 20;\n\n            result = arcLength / this.arcLength;\n\n            for (let i = 0; i <= MAXITERS; i++) {\n                const diff = arcLengthPolynomial.romberg(0, result) - arcLength;\n\n                if (Math.abs(diff) < TOLERANCE) {\n                    break;\n                }\n\n                const value = arcLengthPolynomial.eval(result);\n\n                if (value === 0) {\n                    break;\n                }\n\n                result -= diff / value;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        const polys = this.getBernsteinPolynomials();\n        const dx = polys.x.getDerivative();\n        const dy = polys.y.getDerivative();\n        let roots = dx.getRootsInInterval(0, 1);\n\n        roots = roots.concat(dy.getRootsInInterval(0, 1));\n\n        // initialize min/max using the first and last points on the curve\n        let min = this.p1.min(this.p4);\n        let max = this.p1.max(this.p4);\n\n        // and now update min/max with points between p1 and p4\n        roots.forEach(function(t) {\n            if (0 <= t && t <= 1) {\n                const testPoint = new Point2D(\n                    polys.x.eval(t),\n                    polys.y.eval(t)\n                );\n\n                min = min.min(testPoint);\n                max = max.max(testPoint);\n            }\n        });\n\n        return new BoundingBox2D(\n            min.x,\n            min.y,\n            max.x - min.x,\n            max.y - min.y\n        );\n    }\n\n    /**\n     *  getAlignedBoundingBox\n     *\n     *  @returns {{ bbox: module:kld-contours~BoundingBox2D, transform: module:kld-affine.Matrix2D }}\n     */\n    getAlignedBoundingBox() {\n        return {\n            bbox: this.getAlignedBezier().getBoundingBox(),\n            transform: Matrix2D\n                .translation(this.p1.x, this.p1.y)\n                .rotateFromVector(Vector2D.fromPoints(this.p1, this.p4))\n        };\n    }\n\n    /**\n     *  getAlignedBezier\n     *\n     *  @returns {module:kld-contours~CubicBezier2D}\n     */\n    getAlignedBezier() {\n        const matrix = Matrix2D\n            .translation(this.p1.x, this.p1.y) // move p1 to the origin\n            .rotateFromVector(Vector2D.fromPoints(this.p1, this.p4)) // rotate vector from p1 to p4 to x-axis\n            .inverse(); // reverse transforms\n\n        // apply to each point and create new Bezier\n        return new CubicBezier2D(\n            this.p1.transform(matrix),\n            this.p2.transform(matrix),\n            this.p3.transform(matrix),\n            this.p4.transform(matrix)\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @param {number} [flatness]\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D(flatness) {\n        const points = [];\n        const zeroVector = new Vector2D(0, 0);\n\n        flatness = flatness !== undefined ? flatness : 1.0;\n\n        // add first point\n        points.push(this.p1);\n\n        // add middle points\n        /**\n         *  @param {number} p1\n         *  @param {number} p2\n         *  @param {number} p3\n         *  @param {number} p4\n         */\n        function tesselateInterior(p1, p2, p3, p4) {\n            // round 1\n            const p5 = p1.lerp(p2, 0.5);\n            const p6 = p2.lerp(p3, 0.5);\n            const p7 = p3.lerp(p4, 0.5);\n\n            // round 2\n            const p8 = p5.lerp(p6, 0.5);\n            const p9 = p6.lerp(p7, 0.5);\n\n            // round 3\n            const p10 = p8.lerp(p9, 0.5);\n\n            const baseline = Vector2D.fromPoints(p1, p4);\n            const tangent1 = Vector2D.fromPoints(p1, p2);\n            const tangent2 = Vector2D.fromPoints(p4, p3);\n            let dmax = 0;\n\n            if (zeroVector.equals(tangent1) === false) {\n                const perpendicular = baseline.perpendicular(tangent1);\n\n                dmax = perpendicular.length();\n            }\n            if (zeroVector.equals(tangent2) === false) {\n                const perpendicular = baseline.perpendicular(tangent2);\n\n                dmax = Math.max(dmax, perpendicular.length());\n            }\n\n            if (dmax > flatness) {\n                tesselateInterior(p1, p5, p8, p10);\n                points.push(new Point2D(p10.x, p10.y));\n                tesselateInterior(p10, p9, p7, p4);\n            }\n            else {\n                points.push(new Point2D(p10.x, p10.y));\n            }\n        }\n\n        // add interior points\n        tesselateInterior(this.p1, this.p2, this.p3, this.p4);\n\n        // add last point\n        points.push(this.p4);\n\n        return new Polygon2D(points);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return (\n            \"M\" + this.p1.x + \",\" + this.p1.y + \" \" +\n            \"C\" + this.p2.x + \",\" + this.p2.y +\n            \" \" + this.p3.x + \",\" + this.p3.y +\n            \" \" + this.p4.x + \",\" + this.p4.y\n        );\n    }\n}\n\nexport default CubicBezier2D;\n","/* eslint-disable class-methods-use-this */\n/**\n *  Ellipse2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Ellipse2D\n */\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  Ellipse2D\n */\nclass Ellipse2D {\n    /**\n     *  @param {module:kld-affine.Point2D} center\n     *  @param {number} radiusX\n     *  @param {number} radiusY\n     *  @returns {module:kld-contours~Ellipse2D}\n     */\n    constructor(center, radiusX, radiusY) {\n        this.center = center;\n        this.radiusX = radiusX;\n        this.radiusY = radiusY;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        return new BoundingBox2D(\n            this.center.x - this.radiusX,\n            this.center.y - this.radiusY,\n            this.radiusX * 2.0,\n            this.radiusY * 2.0\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return new Polygon2D();\n    }\n}\n\nexport default Ellipse2D;\n","/**\n *  Line2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Line2D\n */\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  Line2D\n */\nclass Line2D {\n    /**\n     *  @param {module:kld-affine.Point2D} p1\n     *  @param {module:kld-affine.Point2D} p2\n     *  @returns {module:kld-contours~Line2D}\n     */\n    constructor(p1, p2) {\n        this.p1 = p1;\n        this.p2 = p2;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        const min = this.p1.min(this.p2);\n        const max = this.p1.max(this.p2);\n\n        return new BoundingBox2D(\n            min.x,\n            min.y,\n            max.x - min.x,\n            max.y - min.y\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return new Polygon2D([this.p1, this.p2]);\n    }\n}\n\nexport default Line2D;\n","/**\n *  QuadraticBezier2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module QuadraticBezier2D\n */\nimport {Polynomial, SqrtPolynomial} from \"kld-polynomial\";\nimport {Matrix2D, Point2D, Vector2D} from \"kld-affine\";\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  QuadraticBezier2D\n */\nclass QuadraticBezier2D {\n    /**\n     *  @param {module:kld-affine.Point2D} p1\n     *  @param {module:kld-affine.Point2D} p2\n     *  @param {module:kld-affine.Point2D} p3\n     *  @returns {module:kld-contours~QuadraticBezier2D}\n     */\n    constructor(p1, p2, p3) {\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n    }\n\n    /**\n     *  getPointAtParameter\n     *\n     *  @param {number} t\n     *  @returns {module:kld-affine.Point2D}\n     */\n    getPointAtParameter(t) {\n        // TODO: validate t in [0,1]\n\n        // first round of lerps\n        const p4 = this.p1.lerp(this.p2, t);\n        const p5 = this.p2.lerp(this.p3, t);\n\n        return p4.lerp(p5, t);\n    }\n\n    /**\n     *  splitAtParameter\n     *\n     *  @param {number} t\n     *  @returns {Array<module:kld-contours~QuadraticBezier2D>}\n     */\n    splitAtParameter(t) {\n        // first round of lerps\n        const p4 = this.p1.lerp(this.p2, t);\n        const p5 = this.p2.lerp(this.p3, t);\n\n        // second round of lerps\n        const p6 = p4.lerp(p5, t);\n\n        return [\n            new QuadraticBezier2D(this.p1, p4, p6),\n            new QuadraticBezier2D(p6, p5, this.p3)\n        ];\n    }\n\n    /**\n     *  getBernsteinPolynomials\n     *\n     *  @returns {{x: module:kld-polynomial.Polynomial, y: module:kld-polynomial.Polynomial}}\n     */\n    getBernsteinPolynomials() {\n        let a; // temporary variables\n\n        a = this.p2.multiply(-2);\n        const c2 = this.p1.add(a.add(this.p3));\n\n        a = this.p1.multiply(-2);\n        const b = this.p2.multiply(2);\n        const c1 = a.add(b);\n\n        const c0 = this.p1;\n\n        return {\n            x: new Polynomial(c2.x, c1.x, c0.x),\n            y: new Polynomial(c2.y, c1.y, c0.y)\n        };\n    }\n\n    /**\n     *  getArcLengthPolynomial\n     *\n     *  @returns {module:kld-polynomial.SqrtPolynomial}\n     */\n    getArcLengthPolynomial() {\n        /* eslint-disable-next-line no-prototype-builtins */\n        if (!this.hasOwnProperty(\"arcLengthPolynomial\")) {\n            let a;\n\n            a = this.p2.multiply(-2);\n            const c2 = this.p1.add(a.add(this.p3));\n\n            a = this.p1.multiply(-2);\n            const b = this.p2.multiply(2);\n            const c1 = a.add(b);\n\n            //  ____________\n            //  dx^2 + dy^2\n            //\n            this.arcLengthPolynomial = new SqrtPolynomial(\n                4 * (c2.x * c2.x + c2.y * c2.y),\n                4 * (c1.x * c2.x + c1.y * c2.y),\n                c1.x * c1.x + c1.y * c1.y\n            );\n\n            // this.arcLength = this.arcLengthPolynomial.romberg(0, 1);\n            this.arcLength = this.arcLengthPolynomial.simpson(0, 1);\n        }\n\n        return this.arcLengthPolynomial;\n    }\n\n    /**\n     *  getParameterFromArcLength\n     *\n     *  @param {number} arcLength\n     *  @returns {number}\n     */\n    getParameterFromArcLength(arcLength) {\n        // TODO: extract common Bezier code\n\n        // make sure the arc length polynomial and arc length values have been calculated\n        const arcLengthPolynomial = this.getArcLengthPolynomial();\n        let result;\n\n        if (arcLength <= 0) {\n            result = 0;\n        }\n        else if (arcLength >= this.arcLength) {\n            result = 1;\n        }\n        else {\n            const TOLERANCE = 1e-9;\n            const MAXITERS = 20;\n\n            result = arcLength / this.arcLength;\n\n            for (let i = 0; i <= MAXITERS; i++) {\n                const diff = arcLengthPolynomial.romberg(0, result) - arcLength;\n\n                if (Math.abs(diff) < TOLERANCE) {\n                    break;\n                }\n\n                const value = arcLengthPolynomial.eval(result);\n\n                if (value === 0) {\n                    break;\n                }\n\n                result -= diff / value;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        const polys = this.getBernsteinPolynomials();\n        const dx = polys.x.getDerivative();\n        const dy = polys.y.getDerivative();\n        let roots = dx.getRootsInInterval(0, 1);\n        roots = roots.concat(dy.getRootsInInterval(0, 1));\n\n        let min = this.p1.min(this.p3);\n        let max = this.p1.max(this.p3);\n\n        roots.forEach(function(t) {\n            if (0 <= t && t <= 1) {\n                const testPoint = new Point2D(\n                    polys.x.eval(t),\n                    polys.y.eval(t)\n                );\n\n                min = min.min(testPoint);\n                max = max.max(testPoint);\n            }\n        });\n\n        return new BoundingBox2D(\n            min.x,\n            min.y,\n            max.x - min.x,\n            max.y - min.y\n        );\n    }\n\n    /**\n     *  getAlignedBoundingBox\n     *\n     *  @returns {{ bbox: module:kld-contours~BoundingBox2D, transform: module:kld-affine.Matrix2D }}\n     */\n    getAlignedBoundingBox() {\n        return {\n            bbox: this.getAlignedBezier().getBoundingBox(),\n            transform: Matrix2D\n                .translation(this.p1.x, this.p1.y)\n                .rotateFromVector(Vector2D.fromPoints(this.p1, this.p3))\n        };\n    }\n\n    /**\n     *  getAlignedBezier\n     *\n     *  @returns {module:kld-contours~QuadraticBezier2D}\n     */\n    getAlignedBezier() {\n        const matrix = Matrix2D\n            .translation(this.p1.x, this.p1.y) // move p1 to the origin\n            .rotateFromVector(Vector2D.fromPoints(this.p1, this.p3)) // rotate vector from p1 to p4 to x-axis\n            .inverse(); // reverse transforms\n\n        // apply to each point and create new Bezier\n        return new QuadraticBezier2D(\n            this.p1.transform(matrix),\n            this.p2.transform(matrix),\n            this.p3.transform(matrix)\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @param {number} [flatness]\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D(flatness) {\n        const points = [];\n        const zeroVector = new Vector2D(0, 0);\n\n        flatness = flatness !== undefined ? flatness : 1.0;\n\n        // add first point\n        points.push(this.p1);\n\n        // add middle points\n        /**\n         *  @param {number} p1\n         *  @param {number} p2\n         *  @param {number} p3\n         */\n        function tesselateInterior(p1, p2, p3) {\n            // round 1\n            const p4 = p1.lerp(p2, 0.5);\n            const p5 = p2.lerp(p3, 0.5);\n\n            // round 2\n            const p6 = p4.lerp(p5, 0.5);\n\n            const baseline = Vector2D.fromPoints(p1, p3);\n            const tangent = Vector2D.fromPoints(p1, p2);\n            let dmax = 0;\n\n            if (zeroVector.equals(tangent) === false) {\n                const perpendicular = baseline.perpendicular(tangent);\n\n                dmax = perpendicular.length();\n            }\n\n            if (dmax > flatness) {\n                tesselateInterior(p1, p4, p6);\n                points.push(new Point2D(p6.x, p6.y));\n                tesselateInterior(p6, p5, p3);\n            }\n            else {\n                points.push(new Point2D(p6.x, p6.y));\n            }\n        }\n\n        // add interior points\n        tesselateInterior(this.p1, this.p2, this.p3);\n\n        // add last point\n        points.push(this.p3);\n\n        return new Polygon2D(points);\n    }\n\n    /**\n     *  toString\n     *\n     *  @returns {string}\n     */\n    toString() {\n        return (\n            \"M\" + this.p1.x + \",\" + this.p1.y + \" \" +\n            \"Q\" + this.p2.x + \",\" + this.p2.y +\n            \" \" + this.p3.x + \",\" + this.p3.y\n        );\n    }\n}\n\nexport default QuadraticBezier2D;\n","/**\n *  Rectangle2D.js\n *\n *  @copyright 2011-2019 Kevin Lindsey\n *  @module Rectangle2D\n */\nimport {Point2D} from \"kld-affine\";\nimport BoundingBox2D from \"./BoundingBox2D.js\";\nimport Polygon2D from \"./Polygon2D.js\";\n\n/**\n *  Rectangle2D\n */\nclass Rectangle2D {\n    /**\n     *  @param {number} x\n     *  @param {number} y\n     *  @param {number} width\n     *  @param {number} height\n     *  @returns {module:kld-contours~Rectangle2D}\n     */\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n\n    /**\n     *  getBoundingBox\n     *\n     *  @returns {module:kld-contours~BoundingBox2D}\n     */\n    getBoundingBox() {\n        return new BoundingBox2D(\n            this.x,\n            this.y,\n            this.width,\n            this.height\n        );\n    }\n\n    /**\n     *  toPolygon2D\n     *\n     *  @returns {module:kld-contours~Polygon2D}\n     */\n    toPolygon2D() {\n        return new Polygon2D([\n            new Point2D(this.x, this.y),\n            new Point2D(this.x + this.width, this.y),\n            new Point2D(this.x + this.width, this.y + this.height),\n            new Point2D(this.x, this.y + this.height)\n        ]);\n    }\n}\n\nexport default Rectangle2D;\n"],"names":["BoundingBox2D","x","y","width","height","that","this","Polygon2D","points","undefined","length","min","max","i","point","map","p","join","Circle2D","center","radius","sign","NaN","Polynomial","coefs","arguments","push","_variable","_s","poly","slice","isNaN","TypeError","result","d1","getDegree","d2","dmax","Math","v1","v2","j","scalar","TOLERANCE","abs","pop","c","err","reduce","pv","cv","divideEqualsScalar","signs","value","round","signString","ACCURACY","minValue","eval","maxValue","tmp1","log","tmp2","LN10","maxIterations","ceil","LN2","n","range","iter","delta","sum","st","t","s","os","ost","Array","MAX","h","dy","trapezoid","interpolate","maxAbsX","rb","bounds","minX","maxX","an","m","v","nm","pow","a","coefSelectionFunc","b","find2Max","acc","bi","nearmax","max_nearmax_pos","negX","posX","reverse","res","boundsUpperRealFujiwara","urb","boundsLowerRealFujiwara","prev","curr","p1","undersqrt","p2","sqrt","accum","ai","prev_a","pos","neg","maxRealPos","maxRealNeg","minComplex","derivative","simplifyEquals","getLinearRoot","getQuadraticRoots","getCubicRoots","getQuarticRoots","roots","RangeError","bisection","droots","getDerivative","getRootsInInterval","results","d","e","c3","c2","c1","offset","discrim","halfB","ZEROepsilon","zeroErrorEstimate","root","tmp","distance","angle","atan2","cos","sin","sqrt3","poly_d","derrt","getRoots","sort","dery","nr","maxabsX","dx","guesses","minmax","f","df","newtonSecantBisection","concat","xs","ys","constructor","ns","diff","dift","ho","hp","w","den","x0","max_iterations","dfx","x_correction","x_new","y_atmin","y_atmax","prev_dfx","prev_x_ef_correction","min_correction_factor","isBounded","isEnoughCorrection","SqrtPolynomial","Point2D","precision","omt","matrix","Vector2D","divide","dot","radians","acos","cross","subtract","project","percent","multiply","Matrix2D","isIdentity","det1","Error","idet","det2","det3","tx","ty","scale","scaleX","scaleY","cx","cy","vector","unit","tan","E","F","G","H","Q","R","a1","a2","theta","phi","translation","rotation","nonUniformScaling","rotation0","IDENTITY","CubicBezier2D","p3","p4","p5","lerp","p6","p7","p8","p9","p10","add","c0","hasOwnProperty","arcLengthPolynomial","arcLength","romberg","getArcLengthPolynomial","polys","getBernsteinPolynomials","forEach","testPoint","bbox","getAlignedBezier","getBoundingBox","transform","rotateFromVector","fromPoints","inverse","flatness","zeroVector","tesselateInterior","baseline","tangent1","tangent2","equals","perpendicular","Ellipse2D","radiusX","radiusY","Line2D","QuadraticBezier2D","simpson","tangent","Rectangle2D"],"mappings":"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"}